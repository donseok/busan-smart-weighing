# 부산 스마트 계량 시스템 - 운영자 매뉴얼

**문서 번호**: MAN-OPS-002
**버전**: 1.3
**작성일**: 2026-01-30
**대상 독자**: 시스템 관리자 / 운영자 (ADMIN, MANAGER)
**기반 문서**: TRD-20260127-155235, PRD-20260127-154446, FUNC-SPEC v1.0
**상태**: Draft

---

## 목차

1. [시스템 개요](#1-시스템-개요)
2. [설치 및 환경 구성](#2-설치-및-환경-구성)
3. [사용자 관리](#3-사용자-관리)
4. [보안 관리](#4-보안-관리)
5. [시스템 모니터링](#5-시스템-모니터링)
6. [데이터베이스 관리](#6-데이터베이스-관리)
7. [기준정보 관리](#7-기준정보-관리)
   - 7.5 [시스템 설정 관리](#75-시스템-설정-관리)
   - 7.6 [공지사항 관리](#76-공지사항-관리)
   - 7.7 [FAQ 관리](#77-faq-관리)
   - 7.8 [장비 모니터링 관리](#78-장비-모니터링-관리)
   - 7.9 [문의/민원 관리](#79-문의민원-관리)
   - 7.10 [통계/보고서 관리](#710-통계보고서-관리)
   - 7.11 [즐겨찾기 관리](#711-즐겨찾기-관리)
8. [장비 관리](#8-장비-관리)
9. [장애 대응](#9-장애-대응)
10. [백업 및 복구](#10-백업-및-복구)
11. [성능 관리](#11-성능-관리)
12. [운영 체크리스트](#12-운영-체크리스트)
13. [부록](#13-부록)

---

## 1. 시스템 개요

### 1.1 시스템 아키텍처

부산 스마트 계량 시스템은 LPR(차량번호 자동인식) 기반 무인 계량 자동화 시스템이다. 현장 하드웨어, 계량대 클라이언트 프로그램, API 서버, 데이터베이스, 웹/모바일 프론트엔드로 구성된다.

```
+-----------------------------------------------------------------------+
|                        부산공장 계량대 현장                               |
|                                                                       |
|  [LPR 카메라] [LiDAR 센서] [레이더] [차량검지기] [인디게이터]              |
|       |            |          |          |            |               |
|       +------------+----------+----------+------------+               |
|                              |                                        |
|                   +----------v-----------+                            |
|                   | 계량대 CS 프로그램     |<--- RS-232C (인디게이터)    |
|                   | (C# .NET WinForms)   |---- TCP/UDP (LPR/센서)     |
|                   +----------+-----------+                            |
|                              |                                        |
|  [전광판(OTP)]  [자동 차단기]  |         [인터폰(자기/모기)]              |
+------------------------------+----------------------------------------+
                               | HTTPS (REST API)
                               |
+------------------------------+----------------------------------------+
|                         서버 인프라                                     |
|                              |                                        |
|               +--------------v--------------+                         |
|               |    Nginx (Reverse Proxy)     |                         |
|               |   SSL 종단 / 로드밸런싱        |                         |
|               +------+---------------+------+                         |
|                      |               |                                |
|            +---------v----+  +-------v--------+                       |
|            | Spring Boot  |  | Spring Boot    |                       |
|            | WAS #1       |  | WAS #2         |                       |
|            | (API Server) |  | (API Server)   |                       |
|            +------+-------+  +-------+--------+                       |
|                   |                  |                                 |
|            +------v------------------v--------+                       |
|            |         Service Layer            |                       |
|            |  - 배차관리 서비스                  |                       |
|            |  - 계량관리 서비스                  |                       |
|            |  - 사용자/인증 서비스               |                       |
|            |  - OTP 인증 서비스                 |                       |
|            |  - LPR/AI 연동 서비스              |                       |
|            |  - 알림 서비스                     |                       |
|            |  - WebSocket 실시간 전송           |                       |
|            +------+---------------+-----------+                       |
|                   |               |                                   |
|        +----------v--+   +-------v------+   +-----------+             |
|        | PostgreSQL   |   |   Redis     |   | AI 인식   |             |
|        | (Primary +   |   | (Cache/OTP/ |   | Engine    |             |
|        |  Standby)    |   |  MQ/Session)|   |           |             |
|        +-------------+   +-------------+   +-----------+             |
|                                                                       |
|        +---------------------------------------------+               |
|        |  Monitoring: Prometheus + Grafana            |               |
|        |  Logging: ELK Stack                         |               |
|        +---------------------------------------------+               |
+-----------------------------------------------------------------------+
                               |
                    +----------+----------+
                    |          |          |
             +------v--+ +----v----+ +---v----------+
             | 웹(React)| |모바일APP| | 외부 서비스    |
             |          | |(Flutter)| | (카카오/SMS/  |
             |          | |         | |  FCM)        |
             +---------+  +--------+  +-------------+
```

### 1.2 기술 스택

| 구분 | 기술 | 버전 | 용도 |
|------|------|------|------|
| Backend | Java | 17 LTS | API 서버 개발 언어 |
| Backend | Spring Boot | 3.2.5 | 애플리케이션 프레임워크 |
| Backend | Spring Security | 6.x | JWT 인증 + RBAC 인가 |
| Database | PostgreSQL | 16.x | Primary DB (ACID 트랜잭션) |
| Cache | Redis | 7.x | OTP/세션/캐시/메시지큐 |
| Frontend (Web) | React + TypeScript | 18.x / 5.x | 관리 웹 시스템 |
| Frontend (Web) | Ant Design + Vite | 5.x / 5.x | UI 컴포넌트 + 빌드 |
| Frontend (Mobile) | Flutter | 3.x | iOS/Android 모바일 APP |
| 계량대 CS | C# .NET | 11 / 7+ | 계량대 클라이언트 프로그램 |
| Reverse Proxy | Nginx | 1.24.x | SSL 종단, 로드밸런싱 |
| Container | Docker + Docker Compose | Latest | 컨테이너 배포 |
| Monitoring | Prometheus + Grafana | Latest | 메트릭 수집 및 시각화 |
| Logging | ELK Stack | Latest | 중앙 집중 로그 관리 |
| CI/CD | Jenkins / GitLab CI | Latest | 빌드 및 배포 자동화 |
| VCS | Git (GitLab) | Latest | 소스코드 관리 |

### 1.3 네트워크 구성

| 출발지 | 목적지 | 프로토콜 | 포트 | 설명 |
|--------|--------|---------|------|------|
| LPR/센서 장비 | 계량대 CS | TCP/UDP | 설정값 | 차량번호 인식, 센서 이벤트 |
| 인디게이터 | 계량대 CS | RS-232C | COM 포트 | 안정화 중량값 수신 |
| 계량대 CS | 전광판/차단기 | TCP/RS-485 | 설정값 | OTP 표시, 차단기 제어 |
| 계량대 CS | Nginx | HTTPS | 443 | API 호출 |
| React Web | Nginx | HTTPS | 443 | 웹 접근 |
| React Web | Nginx | WSS | 443 | WebSocket 실시간 |
| Flutter App | Nginx | HTTPS | 443 | 모바일 API |
| Nginx | Spring Boot | HTTP | 8080/8081 | 리버스 프록시 |
| Spring Boot | PostgreSQL | TCP | 5432 | DB 연결 |
| Spring Boot | Redis | TCP | 6379 | 캐시/OTP/세션 |
| Spring Boot | AI Engine | HTTPS | 설정값 | 차량번호 AI 검증 |
| Spring Boot | 카카오 API | HTTPS | 443 | 알림톡 발송 |
| Spring Boot | SMS Gateway | HTTPS | 443 | SMS 발송 |
| Spring Boot | FCM | HTTPS | 443 | Push 알림 |

### 1.4 서버 구성

| 환경 | 구성 | 스펙 | 용도 |
|------|------|------|------|
| Production - WAS | VM 2대 (Active-Active) | 8 vCPU, 32GB RAM, 100GB SSD | Spring Boot API Server |
| Production - DB | VM 1대 + Standby | 8 vCPU, 32GB RAM, 500GB SSD | PostgreSQL Primary + Standby |
| Production - Redis | VM 1대 | 4 vCPU, 16GB RAM, 50GB SSD | Redis Cache/OTP/Session |
| Production - Nginx | VM 1대 | 2 vCPU, 4GB RAM, 50GB SSD | Reverse Proxy, SSL 종단 |
| Monitoring | VM 1대 | 4 vCPU, 8GB RAM, 200GB SSD | Prometheus, Grafana, ELK |
| Staging | VM 2대 | 4 vCPU, 16GB RAM, 200GB SSD | 사전 검증 환경 |
| Development | VM 1대 | 4 vCPU, 16GB RAM, 200GB SSD | 개발/테스트 통합 환경 |

> **참고**: 모든 서버는 CentOS / Rocky Linux 9 기반으로 운영하며, 사내 온프레미스 환경에 구축한다.

---

## 2. 설치 및 환경 구성

### 2.1 서버 환경 요구사항

#### 운영체제 요구사항

```
OS: Rocky Linux 9.x (또는 CentOS Stream 9)
Kernel: 5.14 이상
SELinux: enforcing 모드 권장
Firewall: firewalld 활성화
```

#### 필수 패키지 설치

```bash
# 기본 패키지 설치
sudo dnf update -y
sudo dnf install -y \
    curl wget vim git \
    net-tools lsof htop \
    tar gzip unzip \
    openssl ca-certificates

# Java 17 설치 (WAS 서버)
sudo dnf install -y java-17-openjdk java-17-openjdk-devel
java -version
# 출력 예: openjdk version "17.0.x"

# JAVA_HOME 설정
echo 'export JAVA_HOME=/usr/lib/jvm/java-17-openjdk' >> /etc/profile.d/java.sh
source /etc/profile.d/java.sh
```

#### 방화벽 설정

```bash
# Nginx 서버 (외부 접근)
sudo firewall-cmd --permanent --add-service=https
sudo firewall-cmd --permanent --add-port=443/tcp

# WAS 서버 (내부 네트워크 전용)
sudo firewall-cmd --permanent --add-port=8080/tcp
sudo firewall-cmd --permanent --add-port=8081/tcp

# DB 서버 (WAS에서만 접근)
sudo firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="10.x.x.0/24" port protocol="tcp" port="5432" accept'

# Redis 서버 (WAS에서만 접근)
sudo firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="10.x.x.0/24" port protocol="tcp" port="6379" accept'

# Monitoring 서버
sudo firewall-cmd --permanent --add-port=9090/tcp   # Prometheus
sudo firewall-cmd --permanent --add-port=3000/tcp   # Grafana
sudo firewall-cmd --permanent --add-port=5601/tcp   # Kibana

# 방화벽 적용
sudo firewall-cmd --reload
sudo firewall-cmd --list-all
```

### 2.2 Docker 기반 배포

#### Docker 및 Docker Compose 설치

```bash
# Docker 설치
sudo dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
sudo dnf install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin

# Docker 서비스 시작 및 자동 시작 설정
sudo systemctl start docker
sudo systemctl enable docker

# 운영 계정에 Docker 그룹 추가
sudo usermod -aG docker weighing-admin

# 설치 확인
docker --version
docker compose version
```

#### Docker Compose 구성 (docker-compose.yml)

```yaml
version: '3.8'

services:
  # === Spring Boot API Server #1 ===
  weighing-api-1:
    image: registry.internal/weighing-api:${APP_VERSION:-latest}
    container_name: weighing-api-1
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - DB_HOST=${DB_HOST}
      - DB_PORT=${DB_PORT:-5432}
      - DB_NAME=${DB_NAME}
      - DB_USERNAME=${DB_USERNAME}
      - DB_PASSWORD=${DB_PASSWORD}
      - REDIS_HOST=${REDIS_HOST}
      - REDIS_PORT=${REDIS_PORT:-6379}
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - JWT_SECRET=${JWT_SECRET}
      - AES_SECRET_KEY=${AES_SECRET_KEY}
      - CORS_ORIGIN_WEB=${CORS_ORIGIN_WEB}
      - API_INTERNAL_KEY=${API_INTERNAL_KEY}
    volumes:
      - /data/weighing/logs:/app/logs
      - /data/weighing/lpr-images:/app/lpr-images
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    restart: unless-stopped
    networks:
      - weighing-net
    deploy:
      resources:
        limits:
          cpus: '4.0'
          memory: 8G

  # === Spring Boot API Server #2 ===
  weighing-api-2:
    image: registry.internal/weighing-api:${APP_VERSION:-latest}
    container_name: weighing-api-2
    ports:
      - "8081:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - DB_HOST=${DB_HOST}
      - DB_PORT=${DB_PORT:-5432}
      - DB_NAME=${DB_NAME}
      - DB_USERNAME=${DB_USERNAME}
      - DB_PASSWORD=${DB_PASSWORD}
      - REDIS_HOST=${REDIS_HOST}
      - REDIS_PORT=${REDIS_PORT:-6379}
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - JWT_SECRET=${JWT_SECRET}
      - AES_SECRET_KEY=${AES_SECRET_KEY}
      - CORS_ORIGIN_WEB=${CORS_ORIGIN_WEB}
      - API_INTERNAL_KEY=${API_INTERNAL_KEY}
    volumes:
      - /data/weighing/logs:/app/logs
      - /data/weighing/lpr-images:/app/lpr-images
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    restart: unless-stopped
    networks:
      - weighing-net
    deploy:
      resources:
        limits:
          cpus: '4.0'
          memory: 8G

networks:
  weighing-net:
    driver: bridge
```

#### 배포 및 롤링 업데이트 절차

```bash
# 1. 새 이미지 Pull
docker pull registry.internal/weighing-api:${NEW_VERSION}

# 2. WAS #1 업데이트 (서비스 유지: WAS #2가 트래픽 처리)
docker compose stop weighing-api-1
APP_VERSION=${NEW_VERSION} docker compose up -d weighing-api-1

# 3. WAS #1 헬스체크 확인 (최대 90초 대기)
echo "WAS #1 헬스체크 대기..."
for i in $(seq 1 30); do
    STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/actuator/health)
    if [ "$STATUS" = "200" ]; then
        echo "WAS #1 정상 기동 확인"
        break
    fi
    sleep 3
done

# 4. WAS #2 업데이트
docker compose stop weighing-api-2
APP_VERSION=${NEW_VERSION} docker compose up -d weighing-api-2

# 5. WAS #2 헬스체크 확인
echo "WAS #2 헬스체크 대기..."
for i in $(seq 1 30); do
    STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8081/actuator/health)
    if [ "$STATUS" = "200" ]; then
        echo "WAS #2 정상 기동 확인"
        break
    fi
    sleep 3
done

echo "롤링 업데이트 완료: version=${NEW_VERSION}"
```

#### 롤백 절차 (5분 이내)

```bash
# 이전 버전으로 즉시 롤백
ROLLBACK_VERSION="이전_버전_태그"

docker compose stop weighing-api-1 weighing-api-2
APP_VERSION=${ROLLBACK_VERSION} docker compose up -d weighing-api-1 weighing-api-2

# 헬스체크 확인
curl -s http://localhost:8080/actuator/health | python3 -m json.tool
curl -s http://localhost:8081/actuator/health | python3 -m json.tool
```

### 2.3 환경 변수 설정

운영 환경의 환경 변수는 `.env` 파일에서 관리한다. 이 파일은 반드시 `chmod 600`으로 권한을 제한해야 한다.

#### .env 파일 구성

```bash
# 파일 경로: /opt/weighing/.env
# 권한: chmod 600, chown weighing-admin:weighing-admin

# === Database ===
DB_HOST=10.x.x.10
DB_PORT=5432
DB_NAME=weighing
DB_USERNAME=weighing_app
DB_PASSWORD=<강력한_비밀번호>

# === Redis ===
REDIS_HOST=10.x.x.20
REDIS_PORT=6379
REDIS_PASSWORD=<강력한_비밀번호>

# === JWT ===
# Base64로 인코딩된 256bit 이상의 시크릿 키
JWT_SECRET=<Base64_인코딩된_시크릿_키>

# === AES-256 암호화 키 ===
AES_SECRET_KEY=<Base64_인코딩된_AES_키>

# === CORS ===
CORS_ORIGIN_WEB=https://weighing.factory.internal

# === Internal API Key ===
API_INTERNAL_KEY=<계량대_CS_내부_인증키>

# === Application Version ===
APP_VERSION=1.0.0
```

#### 환경 변수 보안 주의사항

- `.env` 파일은 Git에 절대 커밋하지 않는다 (`.gitignore`에 포함 확인).
- 파일 권한을 `600`으로 설정하여 소유자만 읽을 수 있도록 한다.
- JWT_SECRET와 AES_SECRET_KEY는 최소 256bit 이상의 랜덤 값을 Base64로 인코딩하여 사용한다.
- 비밀번호 변경 시 관련 서비스를 순차적으로 재시작해야 한다.

#### 시크릿 키 생성 방법

```bash
# JWT Secret 생성 (256bit)
openssl rand -base64 32

# AES-256 Key 생성
openssl rand -base64 32

# Internal API Key 생성
openssl rand -hex 32
```

### 2.4 Nginx 설정

#### 기본 설정 (/etc/nginx/nginx.conf)

```nginx
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
    multi_accept on;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    # 로그 형식
    log_format main '$remote_addr - $remote_user [$time_local] '
                    '"$request" $status $body_bytes_sent '
                    '"$http_referer" "$http_user_agent" '
                    '$request_time $upstream_response_time';

    access_log /var/log/nginx/access.log main;

    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    client_max_body_size 50M;

    # Gzip 압축
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css application/json application/javascript
               text/xml application/xml image/svg+xml;

    # Rate Limiting
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=30r/s;
    limit_req_zone $binary_remote_addr zone=auth_limit:10m rate=5r/s;

    # Upstream (API 서버 로드밸런싱)
    upstream weighing_api {
        least_conn;
        server 10.x.x.1:8080 max_fails=3 fail_timeout=30s;
        server 10.x.x.1:8081 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }

    include /etc/nginx/conf.d/*.conf;
}
```

#### 사이트 설정 (/etc/nginx/conf.d/weighing.conf)

```nginx
# HTTP -> HTTPS 리다이렉트
server {
    listen 80;
    server_name weighing.factory.internal;
    return 301 https://$host$request_uri;
}

# HTTPS 서버
server {
    listen 443 ssl http2;
    server_name weighing.factory.internal;

    # SSL 인증서
    ssl_certificate     /etc/nginx/ssl/weighing.crt;
    ssl_certificate_key /etc/nginx/ssl/weighing.key;

    # TLS 설정
    ssl_protocols TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_ciphers 'TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256';

    # 보안 헤더
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Frame-Options DENY always;
    add_header X-Content-Type-Options nosniff always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self' wss://$host" always;
    add_header Referrer-Policy strict-origin-when-cross-origin always;

    # React 정적 파일
    location / {
        root /var/www/weighing;
        index index.html;
        try_files $uri $uri/ /index.html;

        # 정적 파일 캐싱
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff2?)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }
    }

    # API 프록시
    location /api/ {
        limit_req zone=api_limit burst=20 nodelay;
        proxy_pass http://weighing_api;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_connect_timeout 5s;
        proxy_read_timeout 30s;
        proxy_send_timeout 10s;
    }

    # 인증 API Rate Limiting (더 엄격)
    location /api/v1/auth/ {
        limit_req zone=auth_limit burst=5 nodelay;
        proxy_pass http://weighing_api;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # WebSocket 프록시
    location /ws/ {
        proxy_pass http://weighing_api;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_read_timeout 86400s;
    }

    # Actuator (내부 네트워크만 허용)
    location /actuator/ {
        allow 10.0.0.0/8;
        deny all;
        proxy_pass http://weighing_api;
        proxy_set_header Host $host;
    }

    # Swagger UI (개발/스테이징 환경만)
    # location /swagger-ui/ {
    #     allow 10.0.0.0/8;
    #     deny all;
    #     proxy_pass http://weighing_api;
    # }
}
```

#### Nginx 설정 검증 및 적용

```bash
# 설정 문법 검증
sudo nginx -t

# 설정 리로드 (무중단)
sudo nginx -s reload

# 전체 재시작 (필요 시)
sudo systemctl restart nginx

# 상태 확인
sudo systemctl status nginx
```

### 2.5 SSL 인증서 관리

#### 인증서 파일 구성

```
/etc/nginx/ssl/
  weighing.crt      # 서버 인증서 (+ 중간 인증서 체인)
  weighing.key       # 개인 키 (chmod 600)
  ca-bundle.crt      # CA 인증서 번들 (필요 시)
```

#### 인증서 설치

```bash
# 인증서 디렉토리 생성
sudo mkdir -p /etc/nginx/ssl
sudo chmod 700 /etc/nginx/ssl

# 인증서 파일 복사
sudo cp weighing.crt /etc/nginx/ssl/
sudo cp weighing.key /etc/nginx/ssl/

# 권한 설정
sudo chmod 644 /etc/nginx/ssl/weighing.crt
sudo chmod 600 /etc/nginx/ssl/weighing.key
sudo chown root:root /etc/nginx/ssl/*
```

#### 인증서 만료 확인

```bash
# 인증서 만료일 확인
openssl x509 -enddate -noout -in /etc/nginx/ssl/weighing.crt
# 출력 예: notAfter=Jan 29 00:00:00 2027 GMT

# 인증서 상세 정보 확인
openssl x509 -text -noout -in /etc/nginx/ssl/weighing.crt | head -20

# 원격 인증서 확인
openssl s_client -connect weighing.factory.internal:443 -servername weighing.factory.internal </dev/null 2>/dev/null | openssl x509 -noout -dates
```

#### 인증서 갱신 절차

1. 새 인증서를 발급받는다 (사내 CA 또는 외부 CA).
2. `/etc/nginx/ssl/` 경로에 새 인증서 파일을 복사한다.
3. `sudo nginx -t`로 설정 검증을 수행한다.
4. `sudo nginx -s reload`로 무중단 적용한다.
5. 브라우저에서 인증서 정보를 확인한다.

> **중요**: 인증서 만료 30일 전에 갱신 절차를 시작한다. 인증서 만료 모니터링 알림을 Prometheus에 설정할 것을 권장한다.

### 2.6 데이터베이스 초기 설정

#### PostgreSQL 설치 및 설정

```bash
# PostgreSQL 16 설치
sudo dnf install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-9-x86_64/pgdg-redhat-repo-latest.noarch.rpm
sudo dnf install -y postgresql16-server postgresql16-contrib
sudo /usr/pgsql-16/bin/postgresql-16-setup initdb
sudo systemctl start postgresql-16
sudo systemctl enable postgresql-16
```

#### 데이터베이스 및 사용자 생성

```sql
-- PostgreSQL 접속
-- sudo -u postgres psql

-- 애플리케이션 사용자 생성
CREATE USER weighing_app WITH PASSWORD '강력한_비밀번호_설정';

-- 데이터베이스 생성
CREATE DATABASE weighing
    OWNER weighing_app
    ENCODING 'UTF8'
    LC_COLLATE 'ko_KR.UTF-8'
    LC_CTYPE 'ko_KR.UTF-8'
    TEMPLATE template0;

-- 권한 설정
GRANT ALL PRIVILEGES ON DATABASE weighing TO weighing_app;
\c weighing
GRANT ALL ON SCHEMA public TO weighing_app;

-- 읽기 전용 사용자 (모니터링용)
CREATE USER weighing_readonly WITH PASSWORD '별도_비밀번호';
GRANT CONNECT ON DATABASE weighing TO weighing_readonly;
GRANT USAGE ON SCHEMA public TO weighing_readonly;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO weighing_readonly;
```

#### pg_hba.conf 설정

```
# /var/lib/pgsql/16/data/pg_hba.conf

# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   all             postgres                                peer
local   all             all                                     scram-sha-256
host    weighing        weighing_app    10.x.x.0/24            scram-sha-256
host    weighing        weighing_readonly 10.x.x.0/24          scram-sha-256
host    replication     replicator      10.x.x.11/32           scram-sha-256
```

#### postgresql.conf 주요 설정 (운영 환경)

```
# /var/lib/pgsql/16/data/postgresql.conf

# 연결 설정
listen_addresses = '10.x.x.10'
port = 5432
max_connections = 200

# 메모리 설정 (32GB RAM 기준)
shared_buffers = 8GB
effective_cache_size = 24GB
work_mem = 64MB
maintenance_work_mem = 2GB

# WAL 설정
wal_level = replica
max_wal_senders = 5
wal_keep_size = 1GB
archive_mode = on
archive_command = 'cp %p /data/pg_archive/%f'

# 로깅
logging_collector = on
log_directory = 'log'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_rotation_age = 1d
log_rotation_size = 100MB
log_min_duration_statement = 3000
log_line_prefix = '%t [%p] %u@%d '

# 성능
checkpoint_completion_target = 0.9
random_page_cost = 1.1
effective_io_concurrency = 200

# Timezone
timezone = 'Asia/Seoul'
```

#### 초기 데이터 투입

```sql
-- 시스템 관리자 계정 생성 (초기 비밀번호: Admin1234!)
-- bcrypt hash (cost=12)
INSERT INTO tb_user (user_name, phone_number, user_role, login_id, password_hash)
VALUES (
    '시스템관리자',
    '010-0000-0000',
    'ADMIN',
    'admin',
    '$2a$12$LJ3MFgfFw.PAGtv.Q0n.aeF8VPx4dSmA5WVUkRrXQJQNvk7z3K5Hm'
);
```

> **중요**: 초기 관리자 계정 생성 후 반드시 비밀번호를 변경해야 한다.

### 2.7 Redis 설정

#### Redis 설치

```bash
sudo dnf install -y redis
sudo systemctl start redis
sudo systemctl enable redis
```

#### redis.conf 주요 설정

```
# /etc/redis/redis.conf

# 네트워크
bind 10.x.x.20
port 6379
protected-mode yes

# 인증
requirepass <강력한_비밀번호>

# 메모리 (16GB RAM 기준)
maxmemory 8gb
maxmemory-policy allkeys-lru

# 영속성
save 3600 1
save 300 100
save 60 10000

# RDB 스냅샷
dbfilename dump.rdb
dir /var/lib/redis

# 로깅
loglevel notice
logfile /var/log/redis/redis.log

# 보안
rename-command FLUSHALL ""
rename-command FLUSHDB ""
rename-command DEBUG ""

# 성능
tcp-keepalive 300
timeout 300
```

#### Redis 연결 확인

```bash
# 로컬 접속 확인
redis-cli -h 10.x.x.20 -a '<비밀번호>' ping
# 출력: PONG

# 메모리 사용량 확인
redis-cli -h 10.x.x.20 -a '<비밀번호>' info memory | grep used_memory_human

# 키 패턴 확인 (운영 중 모니터링)
redis-cli -h 10.x.x.20 -a '<비밀번호>' --scan --pattern 'auth:*' | head -10
redis-cli -h 10.x.x.20 -a '<비밀번호>' --scan --pattern 'otp:*' | head -10
```

---

## 3. 사용자 관리

### 3.1 사용자 역할 체계

시스템은 3가지 역할(Role)을 기반으로 접근 권한을 관리한다.

| 역할 | 코드 | 설명 | 주요 권한 |
|------|------|------|----------|
| 시스템 관리자 | ADMIN | 시스템 전체 운영 관리 | 모든 기능 접근, 사용자 관리, 시스템 설정, 공지/FAQ 관리 |
| 계량 담당자 | MANAGER | 계량 업무 담당 | 배차 등록/수정, 계량 관리, 출문 관리, 기준정보 조회 |
| 운전자 | DRIVER | 차량 운전자 | 모바일 앱 로그인, 배차 조회, 계량 진행, 전자 계량표 |

#### 역할별 접근 권한 매트릭스

| 기능 | ADMIN | MANAGER | DRIVER |
|------|:-----:|:-------:|:------:|
| 사용자 생성/수정/삭제 | O | X | X |
| 역할 변경 | O | X | X |
| 계정 잠금 해제 | O | X | X |
| 비밀번호 초기화 | O | X | X |
| 감사 로그 조회 | O | X | X |
| 시스템 설정 관리 | O | X | X |
| 공지사항 관리 (등록/수정/삭제/고정) | O | X | X |
| FAQ 관리 (등록/수정/삭제) | O | X | X |
| 장비 모니터링 | O | X | X |
| 장비 헬스체크 트리거 | O | X | X |
| 배차 등록/수정 | O | O | X |
| 배차 삭제 | O | X | X |
| 계량 관리 | O | O | X |
| 출문 관리 | O | O | X |
| 기준정보 등록/수정 | O | X | X |
| 기준정보 조회 | O | O | X |
| 통계 조회 | O | O | X |
| 내 배차 조회 | O | O | O |
| 모바일 계량 진행 | X | X | O |
| 전자 계량표 조회 | O | O | O |
| OTP 인증 | X | X | O |

### 3.2 사용자 등록

#### 웹 관리 화면을 통한 등록

1. 웹 시스템에 ADMIN 계정으로 로그인한다.
2. 좌측 메뉴에서 **[시스템 관리] > [사용자 관리]** 를 선택한다.
3. **[신규 등록]** 버튼을 클릭한다.
4. 필수 항목을 입력한다:
   - **로그인 ID**: 3~50자, 영문/숫자 조합 (중복 불가)
   - **비밀번호**: 8자 이상, 영문 + 숫자 필수
   - **사용자 이름**: 실명 입력
   - **전화번호**: 010-XXXX-XXXX 형식 (모바일 OTP 인증에 사용)
   - **역할**: ADMIN / MANAGER / DRIVER 중 선택
   - **소속 운송사**: DRIVER 역할인 경우 필수 선택
5. **[저장]** 버튼을 클릭한다.
6. 등록 완료 메시지를 확인한다.

#### API를 통한 등록

```bash
# 사용자 생성 API
curl -X POST https://weighing.factory.internal/api/v1/users \
  -H "Authorization: Bearer ${ADMIN_TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{
    "loginId": "driver001",
    "password": "SecurePass123",
    "userName": "홍길동",
    "phoneNumber": "010-1234-5678",
    "userRole": "DRIVER",
    "companyId": 1
  }'
```

응답 예시:
```json
{
  "success": true,
  "data": {
    "userId": 10,
    "userName": "홍길동",
    "phoneNumber": "010-****-5678",
    "userRole": "DRIVER",
    "companyName": "ABC운수",
    "isActive": true,
    "createdAt": "2026-01-29T10:00:00+09:00"
  }
}
```

### 3.3 사용자 수정 및 비활성화

#### 사용자 정보 수정

1. **[사용자 관리]** 화면에서 대상 사용자를 검색한다.
2. 사용자 행의 **[수정]** 버튼을 클릭한다.
3. 수정 가능 항목: 사용자 이름, 전화번호, 역할, 소속 운송사.
4. **[저장]** 을 클릭하여 변경 사항을 반영한다.

> **주의**: 로그인 ID는 생성 후 변경할 수 없다.

#### 사용자 비활성화

퇴사자나 더 이상 접근이 필요하지 않은 사용자는 삭제 대신 비활성화 처리한다.

```bash
# 사용자 활성/비활성 토글 API
curl -X PATCH https://weighing.factory.internal/api/v1/users/10/toggle-active \
  -H "Authorization: Bearer ${ADMIN_TOKEN}"
```

비활성화된 계정은 로그인 시 `AUTH_002` 오류(비활성화된 계정)를 반환한다.

### 3.4 비밀번호 정책

| 항목 | 정책 |
|------|------|
| 최소 길이 | 8자 이상 |
| 문자 구성 | 영문 + 숫자 필수 포함 |
| 해싱 알고리즘 | bcrypt (cost factor 12) |
| 로그인 실패 잠금 | 5회 연속 실패 시 30분 잠금 |
| 초기 비밀번호 | ADMIN이 수동 설정 후 사용자에게 전달 |

#### 비밀번호 초기화 절차

사용자가 비밀번호를 분실한 경우:

1. 해당 사용자(또는 관리 부서)가 ADMIN에게 비밀번호 초기화를 요청한다.
2. ADMIN은 **[사용자 관리]** 화면에서 대상 사용자를 검색한다.
3. **[비밀번호 초기화]** 버튼을 클릭한다.
4. 임시 비밀번호를 생성하여 설정한다.
5. 임시 비밀번호를 사용자에게 안전한 채널(직접 전달 등)로 전달한다.
6. 사용자는 로그인 후 비밀번호를 변경한다.

### 3.5 계정 잠금 및 해제

#### 자동 잠금 조건

- 로그인을 연속 5회 실패하면 계정이 자동으로 30분간 잠긴다.
- 잠금 상태에서는 올바른 비밀번호를 입력해도 로그인이 거부된다.
- 30분 경과 후 자동으로 잠금이 해제되고 실패 횟수가 초기화된다.

#### 수동 잠금 해제

ADMIN은 잠금된 계정을 즉시 해제할 수 있다.

```bash
# 계정 잠금 해제 API
curl -X POST https://weighing.factory.internal/api/v1/users/10/unlock \
  -H "Authorization: Bearer ${ADMIN_TOKEN}"
```

웹 화면에서는 **[사용자 관리]** 에서 잠금된 사용자 옆의 **[잠금 해제]** 버튼을 클릭한다.

#### 잠금 상태 확인

```sql
-- DB에서 직접 잠금 상태 확인
SELECT user_id, login_id, user_name, failed_login_count, locked_until,
       CASE WHEN locked_until > NOW() THEN 'LOCKED'
            ELSE 'UNLOCKED' END AS lock_status
FROM tb_user
WHERE failed_login_count > 0 OR locked_until IS NOT NULL;
```

---

## 4. 보안 관리

### 4.1 JWT 인증 구조

시스템은 JWT(JSON Web Token) 기반의 Stateless 인증 방식을 사용한다.

#### 토큰 구성

| 토큰 유형 | 만료 시간 | 저장 위치 | 용도 |
|----------|----------|----------|------|
| Access Token | 30분 (1800초) | 클라이언트 메모리 | API 인증 |
| Refresh Token | 7일 | Redis (SHA-256 해시) | Access Token 갱신 |

#### Access Token Claims (Payload)

```json
{
  "sub": "1",
  "login_id": "admin",
  "role": "ADMIN",
  "company_id": null,
  "device_type": "WEB",
  "jti": "unique-token-id",
  "iss": "weighing-api",
  "iat": 1738123200,
  "exp": 1738125000
}
```

#### 인증 흐름

```
[클라이언트]                    [Nginx]              [Spring Boot]            [Redis]
    |                            |                       |                      |
    |-- POST /auth/login ------->|---proxy------------>  |                      |
    |                            |                       |-- 사용자 검증 -------->|
    |                            |                       |<- 결과 반환 ----------|
    |                            |                       |-- Refresh Token 저장->|
    |<-- Access + Refresh Token--|<-- 토큰 발급 ---------|                      |
    |                            |                       |                      |
    |-- API 요청 (Bearer Token)->|---proxy------------>  |                      |
    |                            |                       |-- JWT 검증            |
    |                            |                       |-- 블랙리스트 확인 ---->|
    |                            |                       |<- 결과 반환 ----------|
    |<-- API 응답 --------------|<-- 응답 반환 ----------|                      |
    |                            |                       |                      |
    |-- POST /auth/refresh ----->|---proxy------------>  |                      |
    |                            |                       |-- Refresh Token 검증->|
    |                            |                       |<- 저장값 비교 --------|
    |<-- 새 Access Token --------|<-- 새 토큰 발급 ------|                      |
```

#### 로그아웃 처리

로그아웃 시 다음 두 가지 처리가 수행된다:
1. Redis에서 Refresh Token을 삭제하여 갱신을 차단한다.
2. Access Token의 JTI를 블랙리스트에 등록하여 잔여 유효 시간 동안 사용을 차단한다.

### 4.2 OTP 인증 관리

OTP는 LPR 차량번호 인식 실패 시 모바일 계량을 위한 보안 수단이다.

#### OTP 처리 흐름

```
[계량대 CS]        [API Server]       [Redis]          [전광판]        [모바일 APP]
    |                   |               |                 |                |
    |-- OTP 생성 요청 -->|               |                 |                |
    |                   |-- 6자리 생성 ->|                 |                |
    |                   |   (TTL 5분)    |                 |                |
    |<-- OTP 코드 ------|               |                 |                |
    |-- OTP 표시 ------>|               |                 |                |
    |                   |               |               [123456]           |
    |                   |               |                 |                |
    |                   |               |                 |   OTP 입력     |
    |                   |<-- 검증 요청 --|-----------------|----+---------->|
    |                   |-- Redis 조회 ->|                 |                |
    |                   |<- 세션 반환 ---|                 |                |
    |                   |-- 코드 검증    |                 |                |
    |                   |-- 검증 성공 시 ->| (키 삭제)      |                |
    |<-- 계량 진행 -----|               |                 |                |
```

#### OTP 정책

| 항목 | 설정값 | 설명 |
|------|--------|------|
| 코드 길이 | 6자리 숫자 | SecureRandom 생성 |
| 유효 시간 (TTL) | 5분 (300초) | Redis TTL 관리 |
| 최대 실패 횟수 | 3회 | 초과 시 OTP 무효화 |
| 일회성 | 검증 성공 시 즉시 삭제 | 재사용 불가 |

#### Redis OTP 키 구조

| 키 패턴 | 값 | TTL | 용도 |
|---------|-----|-----|------|
| `otp:code:{otpCode}` | JSON (세션 데이터) | 5분 | OTP 세션 저장 |
| `otp:scale:{scaleId}` | otpCode 문자열 | 5분 | 계량대별 현재 OTP |
| `otp:fail:{otpCode}` | 실패 횟수 | 5분 | 실패 횟수 카운트 |

#### OTP 장애 시 대응

Redis 장애 시 OTP 서비스는 PostgreSQL의 `tb_otp_session` 테이블을 직접 조회하여 Fallback 처리한다.

### 4.3 암호화 정책

| 대상 | 알고리즘 | 상세 |
|------|---------|------|
| 비밀번호 | bcrypt | cost factor 12, 단방향 해시 |
| 전화번호 (DB 저장) | AES-256-GCM | IV + CipherText + Tag, Base64 인코딩 |
| 통신 | TLS 1.3 | Nginx SSL 종단 |
| JWT 서명 | HMAC-SHA256 | Base64 인코딩 시크릿 키 |
| Refresh Token (Redis) | SHA-256 | 원본 대신 해시 저장 |

#### 암호화 키 관리 지침

- AES 키와 JWT Secret은 환경 변수로 관리한다.
- 키는 최소 256bit(32byte) 이상이어야 한다.
- 키 교체 주기: 연 1회 또는 보안 사고 발생 시 즉시 교체한다.
- 키 교체 시 기존 암호화 데이터의 재암호화 마이그레이션이 필요하다.

### 4.4 접근 제어 (RBAC)

Spring Security 기반 RBAC 정책은 다음과 같이 적용된다.

#### API 엔드포인트별 접근 제어

| HTTP Method | 엔드포인트 패턴 | 필요 역할 |
|-------------|----------------|----------|
| POST | /api/v1/auth/login | 인증 불필요 |
| POST | /api/v1/auth/login/otp | 인증 불필요 |
| POST | /api/v1/auth/refresh | Refresh Token |
| POST | /api/v1/otp/verify | 인증 불필요 |
| POST | /api/v1/otp/generate | Internal API Key |
| DELETE | /api/v1/dispatches/** | ADMIN |
| POST, PUT | /api/v1/master/** | ADMIN |
| POST | /api/v1/dispatches | ADMIN, MANAGER |
| PUT | /api/v1/dispatches/** | ADMIN, MANAGER |
| ALL | /api/v1/gate-passes/** | ADMIN, MANAGER |
| GET | /api/v1/dispatches/my | DRIVER |
| ALL | /api/v1/** (기타) | 인증된 사용자 |
| ALL | /actuator/health | 인증 불필요 |

### 4.5 감사 로그 관리

모든 보안 관련 이벤트는 감사 로그에 기록된다.

#### 기록 대상 이벤트

| 이벤트 | 기록 항목 | 로그 레벨 |
|--------|---------|----------|
| 로그인 성공 | userId, loginId, deviceType, IP, timestamp | INFO |
| 로그인 실패 | loginId, 실패 사유, 실패 횟수, IP | WARN |
| 계정 잠금 | userId, loginId, lockedUntil | WARN |
| 로그아웃 | userId, loginId, deviceType | INFO |
| OTP 생성 | scaleId, vehicleId, plateNumber | INFO |
| OTP 검증 성공 | otpCode(마스킹), phoneNumber(마스킹), vehicleId | INFO |
| OTP 검증 실패 | otpCode(마스킹), phoneNumber(마스킹), 실패 횟수 | WARN |
| 권한 거부 | userId, 요청 URI, 필요 역할 | WARN |
| 사용자 생성/수정 | 수행자 userId, 대상 userId, 변경 내용 | INFO |
| 배차 변경 | 수행자 userId, dispatchId, 변경 내용 | INFO |
| 계량 데이터 변경 | 수행자 userId, weighingId, 변경 내용 | INFO |

#### 감사 로그 형식

```
[AUDIT] {event} | userId={} | ip={} | detail={}
```

예시:
```
[AUDIT] LOGIN_SUCCESS | userId=1 | ip=192.168.1.100 | detail=loginId=admin, device=WEB
[AUDIT] LOGIN_FAILED  | userId=null | ip=192.168.1.100 | detail=loginId=hong, reason=PASSWORD_MISMATCH, attempts=3
[AUDIT] ACCOUNT_LOCKED | userId=5 | ip=192.168.1.100 | detail=loginId=driver01, lockedUntil=2026-01-29T15:30:00
```

#### 감사 로그 조회

웹 관리 화면에서 **[시스템 관리] > [감사 로그]** 메뉴에서 다음 조건으로 검색할 수 있다:
- 기간 (시작일 ~ 종료일)
- 이벤트 유형
- 사용자 ID / 이름
- IP 주소

```sql
-- DB 직접 조회 (필요 시)
SELECT audit_id, event_type, user_id, ip_address, detail, created_at
FROM tb_audit_log
WHERE created_at BETWEEN '2026-01-01' AND '2026-01-31'
  AND event_type = 'LOGIN_FAILED'
ORDER BY created_at DESC
LIMIT 100;
```

### 4.6 보안 모니터링

#### 실시간 모니터링 항목

| 항목 | 임계값 | 대응 |
|------|--------|------|
| 로그인 실패 빈도 | > 10회/분 (동일 IP) | 해당 IP 차단 검토, 브루트포스 공격 의심 |
| 계정 잠금 발생 | > 5건/시간 | 대량 계정 공격 의심, 패턴 분석 |
| 401/403 오류 빈도 | > 50회/분 | 인증 우회 시도 의심 |
| OTP 실패 빈도 | > 20회/분 | OTP 무차별 대입 의심 |
| 비정상 API 호출 패턴 | Rate limit 초과 | 자동 차단 (Nginx rate limiting) |

#### OWASP Top 10 방어 현황

| 위협 | 방어 수단 |
|------|----------|
| SQL Injection | JPA Parameterized Query (PreparedStatement) |
| XSS | React 자동 이스케이프 + CSP 헤더 |
| CSRF | JWT 기반 Stateless (SameSite Cookie 없음) |
| Broken Authentication | bcrypt 해싱, 계정 잠금, JWT 만료 관리 |
| Security Misconfiguration | 환경별 프로파일 분리, 보안 헤더 적용 |
| Sensitive Data Exposure | AES-256 암호화, TLS 1.3, 마스킹 처리 |
| Broken Access Control | RBAC, @PreAuthorize 어노테이션 |
| Injection | Bean Validation, DTO 검증 |
| Insufficient Logging | 감사 로그, ELK Stack |
| SSRF | 내부 네트워크 접근 제한, 화이트리스트 |

---

## 5. 시스템 모니터링

### 5.1 장비 상태 모니터링

계량대 현장 장비의 온라인/오프라인/에러 상태를 실시간으로 모니터링한다.

#### 모니터링 대상 장비

| 장비 | 통신 방식 | 헬스체크 방법 | 점검 주기 |
|------|----------|-------------|----------|
| LPR 카메라 | TCP | TCP 연결 확인 + 촬영 테스트 | 30초 |
| LiDAR 센서 | TCP/UDP | 센서 데이터 수신 확인 | 10초 |
| 레이더 센서 | TCP/UDP | 센서 데이터 수신 확인 | 10초 |
| 차량검지기 | TCP/UDP | 이벤트 수신 확인 | 10초 |
| 인디게이터 | RS-232C | 중량값 수신 확인 | 5초 |
| 전광판 | TCP/RS-485 | 통신 상태 확인 | 30초 |
| 자동 차단기 | TCP/RS-485 | 상태 응답 확인 | 30초 |

#### 장비 상태 표시

웹 관리 화면의 **[시스템 관리] > [장비 모니터링]** 대시보드에서 다음 상태를 확인할 수 있다:

- **ONLINE (정상)**: 장비가 정상적으로 통신 중
- **OFFLINE (오프라인)**: 통신이 끊어진 상태 (3회 연속 헬스체크 실패)
- **ERROR (오류)**: 장비가 응답하지만 비정상 데이터 반환
- **MAINTENANCE (점검)**: 운영자가 수동으로 점검 모드 설정

#### 장비 헬스체크

관리자는 웹 화면 또는 API를 통해 수동으로 장비 헬스체크를 트리거할 수 있다.

- 웹: 장비 모니터링 대시보드에서 **[건강 상태 요약]** 카드 확인 및 **[헬스체크 실행]** 버튼 클릭
- API: `POST /api/v1/monitoring/health-check` (ADMIN 권한)
- 요약 조회: `GET /api/v1/monitoring/summary`로 전체 장비 건강 현황 요약 확인

#### 장비 장애 알림

장비가 OFFLINE 또는 ERROR 상태로 전환되면 자동으로 알림이 발생한다:
- WebSocket을 통한 실시간 대시보드 알림
- 관리자 지정 연락처로 SMS/카카오톡 알림 발송

### 5.2 서버 성능 모니터링 (Prometheus + Grafana)

#### Prometheus 설정

```yaml
# /etc/prometheus/prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

alerting:
  alertmanagers:
    - static_configs:
        - targets: ['localhost:9093']

rule_files:
  - "alerts/*.yml"

scrape_configs:
  # Spring Boot Actuator
  - job_name: 'weighing-api'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets:
          - '10.x.x.1:8080'
          - '10.x.x.1:8081'
        labels:
          app: 'weighing-api'

  # Node Exporter (서버 OS 메트릭)
  - job_name: 'node-exporter'
    static_configs:
      - targets:
          - '10.x.x.1:9100'   # WAS 서버
          - '10.x.x.10:9100'  # DB 서버
          - '10.x.x.20:9100'  # Redis 서버
          - '10.x.x.30:9100'  # Nginx 서버

  # PostgreSQL Exporter
  - job_name: 'postgres-exporter'
    static_configs:
      - targets: ['10.x.x.10:9187']

  # Redis Exporter
  - job_name: 'redis-exporter'
    static_configs:
      - targets: ['10.x.x.20:9121']

  # Nginx Exporter
  - job_name: 'nginx-exporter'
    static_configs:
      - targets: ['10.x.x.30:9113']
```

#### 주요 알림 규칙 (alerts/weighing-alerts.yml)

```yaml
groups:
  - name: weighing-system-alerts
    rules:
      # API 응답 시간 p95 > 1초
      - alert: HighAPILatency
        expr: histogram_quantile(0.95, rate(http_server_requests_seconds_bucket{job="weighing-api"}[5m])) > 1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "API 응답 시간 p95가 1초를 초과합니다"

      # API 에러율 > 1%
      - alert: HighAPIErrorRate
        expr: rate(http_server_requests_seconds_count{status=~"5.."}[5m]) / rate(http_server_requests_seconds_count[5m]) > 0.01
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "API 5xx 에러율이 1%를 초과합니다"

      # CPU 사용률 > 80%
      - alert: HighCPUUsage
        expr: 100 - (avg by(instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 80
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "CPU 사용률 80% 초과: {{ $labels.instance }}"

      # 메모리 사용률 > 85%
      - alert: HighMemoryUsage
        expr: (1 - node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes) * 100 > 85
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "메모리 사용률 85% 초과: {{ $labels.instance }}"

      # 디스크 사용률 > 90%
      - alert: HighDiskUsage
        expr: (1 - node_filesystem_avail_bytes{fstype=~"ext4|xfs"} / node_filesystem_size_bytes{fstype=~"ext4|xfs"}) * 100 > 90
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "디스크 사용률 90% 초과: {{ $labels.instance }}"

      # PostgreSQL 연결 > 80%
      - alert: HighDBConnections
        expr: pg_stat_activity_count / pg_settings_max_connections * 100 > 80
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "DB 연결 사용률 80% 초과"

      # Redis 메모리 > 80%
      - alert: HighRedisMemory
        expr: redis_memory_used_bytes / redis_memory_max_bytes * 100 > 80
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "Redis 메모리 사용률 80% 초과"

      # Spring Boot 인스턴스 다운
      - alert: APIServerDown
        expr: up{job="weighing-api"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "API 서버 인스턴스 다운: {{ $labels.instance }}"
```

#### Grafana 대시보드 구성

다음 대시보드를 구성하여 운영한다:

| 대시보드 | 주요 패널 | 용도 |
|----------|---------|------|
| System Overview | CPU, Memory, Disk, Network | 서버 인프라 상태 |
| API Performance | Request Rate, Latency (p50/p95/p99), Error Rate | API 성능 |
| Database | Connections, Query Duration, TPS, Replication Lag | DB 상태 |
| Redis | Memory Usage, Connected Clients, Hit Rate, Commands/s | 캐시 상태 |
| Business Metrics | Daily Weighings, LPR Recognition Rate, OTP Usage | 업무 지표 |

#### Grafana 접속 정보

```
URL: http://10.x.x.50:3000
초기 계정: admin / (설정된 비밀번호)
```

### 5.3 로그 관리 (ELK Stack)

#### 로그 아키텍처

```
[Spring Boot] --> [Logback JSON] --> [Filebeat] --> [Logstash] --> [Elasticsearch] --> [Kibana]
[Nginx]       --> [Access/Error Log] --> [Filebeat] -+
[PostgreSQL]  --> [PostgreSQL Log]   --> [Filebeat] -+
```

#### Logback 설정 (logback-spring.xml)

```xml
<configuration>
  <appender name="JSON_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>/app/logs/weighing-api.json</file>
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
      <fileNamePattern>/app/logs/weighing-api.%d{yyyy-MM-dd}.json</fileNamePattern>
      <maxHistory>90</maxHistory>
      <totalSizeCap>10GB</totalSizeCap>
    </rollingPolicy>
    <encoder class="net.logstash.logback.encoder.LogstashEncoder">
      <timeZone>Asia/Seoul</timeZone>
    </encoder>
  </appender>

  <root level="INFO">
    <appender-ref ref="JSON_FILE" />
  </root>
</configuration>
```

#### Filebeat 설정

```yaml
# /etc/filebeat/filebeat.yml
filebeat.inputs:
  - type: log
    paths:
      - /data/weighing/logs/*.json
    json.keys_under_root: true
    json.add_error_key: true
    fields:
      app: weighing-api

  - type: log
    paths:
      - /var/log/nginx/access.log
    fields:
      app: nginx-access

  - type: log
    paths:
      - /var/log/nginx/error.log
    fields:
      app: nginx-error

output.logstash:
  hosts: ["10.x.x.50:5044"]
```

#### Kibana에서 로그 조회

```
URL: http://10.x.x.50:5601

주요 검색 패턴:
- 에러 로그: level:ERROR AND app:weighing-api
- 감사 로그: message:"[AUDIT]*"
- 느린 API: response_time:>1000
- 특정 사용자: userId:10
- OTP 관련: message:"OTP*"
```

#### 로그 보관 정책

| 로그 유형 | 보관 기간 | 저장 위치 |
|----------|----------|----------|
| 애플리케이션 로그 | 90일 | ELK + 로컬 파일 |
| 감사 로그 | 1년 | ELK + DB (tb_audit_log) |
| Nginx Access 로그 | 90일 | ELK + 로컬 파일 |
| PostgreSQL 로그 | 30일 | 로컬 파일 |
| LPR 이미지 | 90일 | NAS 파일 스토리지 |

### 5.4 알림 설정

#### 알림 채널 구성

| 채널 | 대상 | 용도 |
|------|------|------|
| Grafana Alert → SMS | 운영 담당자 | 서버/DB 장애 (Critical) |
| Grafana Alert → 카카오톡 | 운영 팀 그룹 | 성능 저하 경고 (Warning) |
| WebSocket Push | 웹 대시보드 | 실시간 장비 상태 변경 |
| 이메일 | 운영 팀 | 일일 운영 보고서 |

#### Alertmanager 설정

```yaml
# /etc/alertmanager/alertmanager.yml
global:
  resolve_timeout: 5m

route:
  group_by: ['alertname', 'severity']
  group_wait: 30s
  group_interval: 5m
  repeat_interval: 1h
  receiver: 'default'
  routes:
    - match:
        severity: critical
      receiver: 'critical-sms'
      repeat_interval: 15m
    - match:
        severity: warning
      receiver: 'warning-kakao'
      repeat_interval: 30m

receivers:
  - name: 'default'
    webhook_configs:
      - url: 'http://localhost:8080/api/internal/alerts'

  - name: 'critical-sms'
    webhook_configs:
      - url: 'http://localhost:8080/api/internal/alerts/sms'

  - name: 'warning-kakao'
    webhook_configs:
      - url: 'http://localhost:8080/api/internal/alerts/kakao'
```

---

## 6. 데이터베이스 관리

### 6.1 테이블 구조 및 관계

#### 주요 테이블 목록

| 테이블명 | 설명 | 주요 관계 |
|---------|------|----------|
| tb_user | 사용자 (ADMIN/MANAGER/DRIVER) | tb_company (FK) |
| tb_company | 운송사 마스터 | tb_user, tb_vehicle, tb_dispatch (부모) |
| tb_vehicle | 차량 마스터 (LPR 매칭 기준) | tb_company (FK) |
| tb_dispatch | 배차 기록 | tb_vehicle, tb_company, tb_user (FK) |
| tb_weighing | 계량 실적 | tb_dispatch, tb_vehicle, tb_scale (FK) |
| tb_weighing_slip | 전자 계량표 | tb_weighing (FK) |
| tb_gate_pass | 출문 기록 | tb_weighing, tb_dispatch (FK) |
| tb_otp_session | OTP 세션 | tb_user, tb_vehicle (FK) |
| tb_scale | 계량대 마스터 | tb_weighing (부모) |
| tb_master_code | 공통 코드 | 자기 참조 (parent_code_id) |
| tb_audit_log | 감사 로그 | - |
| tb_notification | 알림 | tb_user (FK) |
| tb_inquiry_call | 문의 통화 기록 | tb_user (FK) |

#### 인덱스 현황

```sql
-- 인덱스 목록 조회
SELECT schemaname, tablename, indexname, indexdef
FROM pg_indexes
WHERE schemaname = 'public'
ORDER BY tablename, indexname;
```

주요 인덱스:

| 테이블 | 인덱스 | 컬럼 | 유형 |
|--------|--------|------|------|
| tb_vehicle | idx_vehicle_plate | plate_number | B-Tree UNIQUE |
| tb_dispatch | idx_dispatch_date_status | dispatch_date, dispatch_status | B-Tree |
| tb_weighing | idx_weighing_dispatch | dispatch_id | B-Tree |
| tb_weighing | idx_weighing_date | weighed_at | B-Tree |
| tb_weighing_slip | idx_slip_number | slip_number | B-Tree UNIQUE |
| tb_user | idx_user_login | login_id | B-Tree UNIQUE |
| tb_otp_session | idx_otp_code_expires | otp_code, expires_at | B-Tree |

### 6.2 백업 및 복구 절차

#### 백업 정책

| 백업 유형 | 대상 | 방식 | 주기 | 보관 기간 |
|----------|------|------|------|----------|
| 전체 백업 | PostgreSQL | pg_dump | 매일 02:00 | 30일 |
| WAL 아카이브 | PostgreSQL | 연속 아카이브 | 실시간 | 7일 |
| RDB 스냅샷 | Redis | RDB dump | 6시간마다 | 3일 |
| LPR 이미지 | NAS | rsync | 매일 03:00 | 90일 |

#### 자동 백업 스크립트 (pg_backup.sh)

```bash
#!/bin/bash
# /opt/weighing/scripts/pg_backup.sh

BACKUP_DIR="/data/backup/postgresql"
DB_NAME="weighing"
DB_USER="weighing_app"
RETENTION_DAYS=30
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="${BACKUP_DIR}/weighing_${TIMESTAMP}.sql.gz"

# 백업 디렉토리 확인
mkdir -p ${BACKUP_DIR}

# pg_dump 실행 (Custom 포맷, 압축)
echo "[$(date)] 백업 시작: ${BACKUP_FILE}"
pg_dump -h ${DB_HOST} -U ${DB_USER} -d ${DB_NAME} \
    --format=custom --compress=9 \
    --file=${BACKUP_FILE}

if [ $? -eq 0 ]; then
    echo "[$(date)] 백업 성공: $(du -sh ${BACKUP_FILE})"
else
    echo "[$(date)] 백업 실패!" >&2
    # 알림 발송
    exit 1
fi

# 오래된 백업 삭제
find ${BACKUP_DIR} -name "weighing_*.sql.gz" -mtime +${RETENTION_DAYS} -delete
echo "[$(date)] ${RETENTION_DAYS}일 이전 백업 파일 정리 완료"
```

#### crontab 등록

```bash
# crontab -e
# 매일 02:00에 PostgreSQL 전체 백업
0 2 * * * /opt/weighing/scripts/pg_backup.sh >> /var/log/weighing/backup.log 2>&1
```

#### 복구 절차

```bash
# 1. 백업 파일 목록 확인
ls -lah /data/backup/postgresql/

# 2. 복구 대상 확인 (테이블 목록)
pg_restore --list /data/backup/postgresql/weighing_20260129_020000.sql.gz

# 3. 전체 복구 (새 DB에)
createdb -h ${DB_HOST} -U postgres weighing_restored
pg_restore -h ${DB_HOST} -U postgres \
    -d weighing_restored \
    --clean --if-exists \
    /data/backup/postgresql/weighing_20260129_020000.sql.gz

# 4. 특정 테이블만 복구
pg_restore -h ${DB_HOST} -U postgres \
    -d weighing \
    --table=tb_weighing \
    --data-only \
    /data/backup/postgresql/weighing_20260129_020000.sql.gz
```

### 6.3 데이터 마이그레이션

기존 레거시 시스템에서 데이터를 이관하는 절차이다.

#### 마이그레이션 원칙

1. **단계별 이관**: 기준정보(운송사, 차량) -> 이력 데이터(배차, 계량) 순서로 진행한다.
2. **병행 운영**: 마이그레이션 기간 동안 기존 시스템과 병행 운영한다.
3. **검증 구간**: 각 단계 완료 후 데이터 정합성 검증을 수행한다.
4. **롤백 계획**: 각 단계별 롤백 절차를 사전에 준비한다.

#### 마이그레이션 검증 쿼리

```sql
-- 데이터 건수 비교
SELECT 'tb_company' AS table_name, COUNT(*) AS cnt FROM tb_company
UNION ALL SELECT 'tb_vehicle', COUNT(*) FROM tb_vehicle
UNION ALL SELECT 'tb_user', COUNT(*) FROM tb_user
UNION ALL SELECT 'tb_dispatch', COUNT(*) FROM tb_dispatch
UNION ALL SELECT 'tb_weighing', COUNT(*) FROM tb_weighing;

-- 차량번호 중복 확인
SELECT plate_number, COUNT(*) AS cnt
FROM tb_vehicle
GROUP BY plate_number
HAVING COUNT(*) > 1;

-- 배차-계량 데이터 정합성 확인
SELECT d.dispatch_id, d.dispatch_status,
       COUNT(w.weighing_id) AS weighing_count
FROM tb_dispatch d
LEFT JOIN tb_weighing w ON d.dispatch_id = w.dispatch_id
WHERE d.dispatch_status = 'COMPLETED'
GROUP BY d.dispatch_id, d.dispatch_status
HAVING COUNT(w.weighing_id) = 0;
```

### 6.4 성능 튜닝

#### 슬로우 쿼리 모니터링

```sql
-- 실행 시간 3초 이상 쿼리 확인 (pg_stat_statements 확장)
SELECT query, calls, total_exec_time / calls AS avg_time_ms,
       rows / calls AS avg_rows
FROM pg_stat_statements
WHERE total_exec_time / calls > 3000
ORDER BY total_exec_time DESC
LIMIT 20;

-- 현재 실행 중인 쿼리 확인
SELECT pid, now() - pg_stat_activity.query_start AS duration,
       query, state
FROM pg_stat_activity
WHERE (now() - pg_stat_activity.query_start) > interval '5 seconds'
  AND state != 'idle';
```

#### 테이블 통계 갱신

```sql
-- 전체 테이블 통계 갱신 (주 1회 권장)
ANALYZE VERBOSE;

-- 특정 테이블 통계 갱신
ANALYZE tb_weighing;
ANALYZE tb_dispatch;
```

#### VACUUM 관리

```sql
-- 자동 VACUUM 상태 확인
SELECT schemaname, relname, n_dead_tup, last_autovacuum, last_autoanalyze
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY n_dead_tup DESC;

-- 수동 VACUUM (필요 시)
VACUUM (VERBOSE, ANALYZE) tb_weighing;
```

#### Connection Pool 모니터링

```sql
-- 현재 연결 상태 확인
SELECT state, COUNT(*)
FROM pg_stat_activity
GROUP BY state;

-- 최대 연결 수 확인
SHOW max_connections;

-- 유휴 연결 확인
SELECT pid, usename, client_addr, state, query_start
FROM pg_stat_activity
WHERE state = 'idle'
  AND query_start < now() - interval '30 minutes';
```

---

## 7. 기준정보 관리

### 7.1 운송사 관리

운송사(tb_company) 정보는 배차, 차량, 사용자의 기준이 되는 마스터 데이터이다.

#### 운송사 등록

웹 관리 화면 **[기준정보 관리] > [운송사 관리]** 에서 다음 정보를 등록한다:

| 항목 | 필수 | 설명 |
|------|:----:|------|
| 운송사명 | O | 업체 정식 명칭 |
| 사업자등록번호 | O | 10자리 |
| 운송사 유형 | O | 부산물/폐기물/부재료/반출/일반 |
| 대표자명 | O | 대표자 성명 |
| 연락처 | O | 대표 전화번호 |
| 주소 | X | 업체 소재지 |
| 활성 상태 | O | 기본값: 활성 |

#### 운송사 비활성화

거래가 종료된 운송사는 삭제하지 않고 비활성화 처리한다. 비활성화된 운송사 소속 차량과 운전자는 배차 등록 시 선택 목록에서 제외된다.

### 7.2 차량 관리 (LPR 매칭)

차량(tb_vehicle) 정보는 LPR 자동 매칭의 핵심 기준 데이터이다.

#### 차량 등록

| 항목 | 필수 | 설명 |
|------|:----:|------|
| 차량번호 | O | LPR 매칭 기준. **시스템 전체에서 고유(UNIQUE)** |
| 소속 운송사 | O | FK: tb_company |
| 차량 유형 | O | 덤프트럭/카고트럭/탱크로리 등 |
| 최대 적재 중량 (kg) | X | 과적 경고 기준 |
| 활성 상태 | O | 기본값: 활성 |

> **중요**: 차량번호(plate_number)는 LPR 카메라가 인식한 결과와 매칭하는 유일한 키이다. 차량번호가 변경된 경우(번호판 교체 등) 반드시 시스템에서도 즉시 업데이트해야 한다. 그렇지 않으면 LPR 자동 계량이 실패한다.

#### 차량번호 형식 관리

```
표준 형식 예시:
  - 12가3456    (일반 차량)
  - 123가4567   (신규 체계)
  - 부산12가3456 (지역 포함)
```

LPR 카메라에서 인식된 번호와 DB에 저장된 번호의 형식이 일치해야 매칭이 성공한다. 등록 시 공백, 하이픈 등 불필요한 문자를 제거하고 표준화된 형식으로 저장한다.

#### 차량 일괄 등록

대량의 차량을 등록해야 하는 경우 Excel 업로드 기능을 사용한다:
1. **[차량 관리]** 화면에서 **[템플릿 다운로드]** 를 클릭하여 양식을 받는다.
2. 양식에 맞게 데이터를 입력한다.
3. **[일괄 업로드]** 버튼으로 파일을 업로드한다.
4. 검증 결과를 확인하고 오류 항목을 수정한다.
5. 확인 후 일괄 등록을 실행한다.

### 7.3 계량대 관리

계량대(tb_scale)는 물리적 계량 장비의 마스터 정보이다.

| 항목 | 필수 | 설명 |
|------|:----:|------|
| 계량대 명칭 | O | 예: "1번 계량대", "부산물 계량대" |
| 설치 위치 | O | 공장 내 위치 정보 |
| 계량대 유형 | O | SMART (자동) / MANUAL (수동) |
| 최대 용량 (kg) | X | 계량 가능 최대 중량 |
| 활성 상태 | O | 운영 여부 |
| 최종 교정 일시 | X | 마지막 교정 날짜 |

#### 계량대 교정 관리

- 계량대는 정기적으로 교정을 받아야 한다 (법정 교정 주기 준수).
- `last_calibrated_at` 필드를 통해 교정 이력을 관리한다.
- 교정 만료일 접근 시 알림을 발송하도록 설정한다.

### 7.4 공통 코드 관리

공통 코드(tb_master_code)는 시스템 전반에서 사용되는 코드 값을 중앙 관리한다.

#### 주요 코드 그룹

| 코드 그룹 | 설명 | 코드 값 예시 |
|----------|------|-------------|
| ITEM_TYPE | 품목 유형 | 부산물, 폐기물, 부재료, 반출, 일반 |
| VEHICLE_TYPE | 차량 유형 | 덤프트럭, 카고트럭, 탱크로리 |
| DISPATCH_STATUS | 배차 상태 | REGISTERED, IN_PROGRESS, COMPLETED, CANCELLED |
| WEIGHING_TYPE | 계량 차수 | FIRST, SECOND, THIRD |
| WEIGHING_MODE | 계량 방식 | LPR_AUTO, MOBILE_OTP, MANUAL, RE_WEIGH |
| WEIGHING_STATUS | 계량 상태 | IN_PROGRESS, COMPLETED, RE_WEIGHING, ERROR |
| INQUIRY_TYPE | 문의 유형 | 물류관제실, 자재창고, 기타 |

#### 코드 추가/수정

1. **[기준정보 관리] > [공통 코드 관리]** 화면에 접근한다.
2. 코드 그룹을 선택하거나 신규 그룹을 생성한다.
3. 코드 값, 코드명, 정렬 순서를 입력한다.
4. 저장 후 관련 화면에서 즉시 반영된다 (Redis 캐시 갱신).

> **주의**: 기존 데이터에서 참조 중인 코드 값은 삭제할 수 없다. 비활성화 처리만 가능하다.

### 7.5 시스템 설정 관리

시스템 설정 관리(`/admin/settings`)에서는 시스템 전반의 운영 파라미터를 조정한다. ADMIN 역할만 접근할 수 있다.

#### 시스템 설정 화면

1. 좌측 메뉴에서 **[시스템 관리] > [시스템 설정]**을 선택한다.
2. 카테고리별로 설정 항목이 표시된다.
3. 설정 값을 변경한 후 **[저장]** 버튼을 클릭한다.
4. 개별 항목 수정 또는 **일괄 수정** 기능을 사용할 수 있다.

#### 설정 카테고리

시스템 설정은 다음 4개 카테고리로 분류된다:

| 카테고리 | 설명 | 설정 예시 |
|----------|------|-----------|
| 일반 (GENERAL) | 시스템 기본 운영 파라미터 | 시스템 명칭, 기본 언어, 타임존 |
| 계량 (WEIGHING) | 계량 프로세스 관련 설정 | 안정화 대기 시간, 최대 재계량 횟수, 과적 기준 비율 |
| 알림 (NOTIFICATION) | 알림 발송 관련 설정 | FCM 활성화 여부, 알림 보관 기간, SMS 발송 활성화 |
| 보안 (SECURITY) | 보안 및 인증 관련 설정 | 세션 타임아웃, 비밀번호 만료 일수, 최대 로그인 실패 횟수 |

#### 설정 값 유형

각 설정 항목은 다음 데이터 유형 중 하나를 가진다:

| 유형 | 설명 | 입력 형태 |
|------|------|-----------|
| 문자열 (STRING) | 텍스트 값 | 텍스트 입력란 |
| 숫자 (NUMBER) | 정수 또는 소수점 값 | 숫자 입력란 |
| 참/거짓 (BOOLEAN) | 활성화/비활성화 값 | 토글 스위치 |
| JSON | 복합 구조 데이터 | JSON 편집기 |

#### 개별 설정 수정

1. 설정 목록에서 변경할 항목을 찾는다 (카테고리 탭으로 필터링 가능).
2. 해당 항목의 **[수정]** 버튼을 클릭한다.
3. 새 설정값을 입력한다.
4. **[저장]** 버튼을 클릭하면 변경이 즉시 적용된다.

> **참고**: 일부 설정은 **편집 불가(읽기 전용)**로 지정되어 있다. 이러한 설정은 환경 변수 또는 서버 설정 파일에서만 변경할 수 있으며, 화면에서 수정 버튼이 비활성화된다.

#### 일괄 설정 수정

여러 설정을 한꺼번에 변경해야 하는 경우 일괄 수정 기능을 사용한다:

1. 설정 화면 상단의 **[일괄 수정]** 버튼을 클릭한다.
2. 변경할 설정 항목들의 값을 수정한다.
3. **[일괄 저장]** 버튼을 클릭하면 모든 변경 사항이 한 번에 적용된다.

> **주의**: 시스템 설정 변경은 즉시 적용된다. 변경 전 현재 값을 기록해 두고, 변경 후 정상 동작을 확인한다. 설정 변경 내역은 감사 로그에 자동 기록된다.

### 7.6 공지사항 관리

관리자(ADMIN)는 웹 시스템에서 공지사항을 생성, 수정, 삭제하고 게시 상태를 관리할 수 있다. 공지사항 관리 기능은 ADMIN 역할에게만 제공된다.

#### 공지사항 생성

1. 좌측 메뉴에서 **[공지사항]**을 클릭하고, **[신규 등록]** 버튼을 클릭한다.
2. 다음 항목을 입력한다:

   | 입력 항목 | 필수 | 설명 |
   |-----------|:----:|------|
   | 제목 | O | 공지사항 제목 |
   | 카테고리 | O | 시스템 / 점검 / 업데이트 / 일반 중 선택 |
   | 내용 | O | 공지사항 본문 |

3. **[저장]** 버튼을 클릭한다. 저장 후 기본적으로 **비공개(미발행)** 상태이다.

#### 공지사항 카테고리

| 카테고리 | 설명 | 사용 예시 |
|----------|------|-----------|
| 시스템 | 시스템 관련 중요 안내 | 서버 이전, 시스템 업그레이드 |
| 점검 | 정기/비정기 점검 안내 | 야간 점검, 장비 교정 일정 |
| 업데이트 | 기능 추가 및 변경 안내 | 신규 기능 출시, UI 변경 안내 |
| 일반 | 기타 운영 공지 | 운영 시간 변경, 일반 안내사항 |

#### 공지사항 수정/삭제

- **수정**: 공지사항 목록에서 대상 항목의 **[수정]** 버튼을 클릭하여 제목, 내용, 카테고리를 변경할 수 있다.
- **삭제**: 공지사항 목록에서 대상 항목의 **[삭제]** 버튼을 클릭한다. 삭제된 공지는 복구할 수 없으므로 신중하게 처리한다.

#### 발행(Publish) 토글

공지사항은 **공개(발행)** 또는 **비공개(미발행)** 상태를 가진다.

- 공지사항 목록에서 대상 공지의 **[발행]** 토글을 클릭하면 사용자에게 공개된다.
- 발행 시 **발행일시**가 자동으로 기록된다.
- 발행된 공지를 비공개로 전환하려면 토글을 다시 클릭한다. 비공개 전환 후에도 기존 발행일시 기록은 유지된다.

> **참고**: 비공개(미발행) 상태의 공지사항은 일반 사용자에게 표시되지 않으며, ADMIN 전용 관리 목록에서만 확인할 수 있다.

#### 고정(Pin) 토글

중요한 공지사항을 목록 상단에 고정할 수 있다.

- 공지사항 목록에서 대상 공지의 **[고정]** 토글을 클릭하면 목록 최상단에 고정 표시된다.
- 고정된 공지를 해제하려면 토글을 다시 클릭한다.
- 여러 공지를 동시에 고정할 수 있으며, 고정된 공지들은 발행일시 기준 내림차순으로 정렬된다.

#### 관리자 전용 목록

ADMIN은 **[공지사항 관리]** 화면에서 비공개 공지를 포함한 전체 목록을 조회할 수 있다. 관리자 전용 목록에서는 다음 정보를 추가로 확인할 수 있다:

- 발행 여부 상태 표시 (발행/미발행 배지)
- 고정 여부 상태 표시
- 발행일시
- 작성자 정보

### 7.7 FAQ 관리

관리자(ADMIN)는 자주 묻는 질문(FAQ)을 생성, 수정, 삭제하고 공개 여부를 관리할 수 있다.

#### FAQ 생성

1. 좌측 메뉴에서 **[도움말]**을 클릭하고, **[FAQ 관리]** 탭을 선택한다.
2. **[신규 등록]** 버튼을 클릭한다.
3. 다음 항목을 입력한다:

   | 입력 항목 | 필수 | 설명 |
   |-----------|:----:|------|
   | 카테고리 | O | 계량 / 배차 / 계정 / 시스템 / 기타 중 선택 |
   | 질문 | O | 자주 묻는 질문 내용 |
   | 답변 | O | 질문에 대한 상세 답변 |
   | 정렬 순서 | O | 목록 표시 순서 (숫자가 작을수록 상위 표시) |

4. **[저장]** 버튼을 클릭한다. 기본적으로 **공개** 상태로 저장된다.

#### FAQ 카테고리

| 카테고리 | 설명 | 질문 예시 |
|----------|------|-----------|
| 계량 | 계량 프로세스 관련 질문 | 재계량은 어떻게 요청하나요? |
| 배차 | 배차 관리 관련 질문 | 배차 등록 후 수정이 가능한가요? |
| 계정 | 로그인 및 계정 관련 질문 | 비밀번호를 분실했습니다. |
| 시스템 | 시스템 이용 관련 질문 | 지원하는 브라우저는 무엇인가요? |
| 기타 | 기타 일반 질문 | 운영 시간은 언제인가요? |

#### FAQ 수정

FAQ 목록에서 대상 항목의 **[수정]** 버튼을 클릭하여 다음 항목을 변경할 수 있다:

- 질문 내용
- 답변 내용
- 카테고리
- 정렬 순서
- 공개 여부 (공개/비공개 토글)

비공개로 전환된 FAQ는 일반 사용자에게 표시되지 않으며, 관리자 전용 목록에서만 확인할 수 있다.

#### FAQ 삭제

- FAQ 목록에서 대상 항목의 **[삭제]** 버튼을 클릭한다.
- 삭제된 FAQ는 즉시 사용자 화면에서 제거되며 복구할 수 없다.

#### 관리자 전용 목록

ADMIN은 **[FAQ 관리]** 화면에서 비공개 FAQ를 포함한 전체 목록을 조회할 수 있다. 관리자 전용 목록에서는 다음 정보를 추가로 확인할 수 있다:

- 공개 여부 상태 표시 (공개/비공개 배지)
- 조회수 통계 (각 FAQ가 사용자에게 조회된 횟수)
- 정렬 순서 값
- 작성일시 및 수정일시

> **참고**: 조회수 통계를 활용하여 사용자가 자주 찾는 질문을 파악하고, 정렬 순서를 조정하여 중요도 높은 FAQ를 상위에 배치할 수 있다.

### 7.8 장비 모니터링 관리

장비 모니터링 관리에서는 계량대 현장에 설치된 모든 장비의 연결 상태를 실시간으로 확인하고 관리한다.

#### 장비 상태 조회

웹 관리 화면의 **[시스템 관리] > [장비 모니터링]**에서 전체 장비 상태를 조회할 수 있다. 다음 기준으로 필터링이 가능하다:

**유형별 필터**:

| 장비 유형 | 영문 코드 | 설명 |
|-----------|-----------|------|
| 계량대 | SCALE | 차량 중량을 측정하는 계량 장비 |
| LPR 카메라 | LPR_CAMERA | 차량번호판을 인식하는 카메라 |
| 지시기 (인디게이터) | INDICATOR | 중량값을 표시/전송하는 장치 |
| 차단기 | BARRIER | 출입 차량을 통제하는 차단기 |

**상태별 필터**:

| 상태 | 표시 색상 | 설명 |
|------|-----------|------|
| ONLINE (정상) | 녹색 | 장비가 정상적으로 통신 중 |
| OFFLINE (오프라인) | 회색 | 통신이 끊어진 상태 |
| ERROR (오류) | 적색 | 장비가 응답하지만 비정상 데이터 반환 |

#### 장비 상태 수동 변경

관리자(ADMIN, MANAGER)는 장비의 연결 상태를 수동으로 변경할 수 있다:

1. 장비 목록에서 대상 장비를 선택한다.
2. **[상태 변경]** 버튼을 클릭한다.
3. 연결 상태(ONLINE/OFFLINE/ERROR)를 선택하고 필요 시 오류 메시지를 입력한다.
4. **[저장]** 버튼을 클릭하면 상태가 즉시 변경된다.

> **참고**: 장비 상태가 변경되면 WebSocket을 통해 실시간으로 모든 접속 중인 사용자에게 알림이 전송된다. 장비 모니터링 화면과 계량소 관제 화면에서 변경된 상태가 즉시 반영된다.

#### 헬스체크 실행

관리자(ADMIN)는 수동으로 전체 장비 헬스체크를 실행할 수 있다:

1. 장비 모니터링 화면에서 **[헬스체크 실행]** 버튼을 클릭한다.
2. 시스템이 모든 등록 장비에 대해 통신 상태를 점검한다.
3. **5분 이상 무응답** 장비는 자동으로 OFFLINE 상태로 전환된다.
4. 헬스체크 결과가 화면에 표시된다.

API를 통한 헬스체크 실행:

```
POST /api/v1/monitoring/health-check
Authorization: Bearer {admin_access_token}
```

#### 장비 요약 대시보드

장비 모니터링 화면 상단에 장비 건강 상태 요약이 카드 형태로 표시된다:

| 요약 항목 | 설명 |
|-----------|------|
| 총 장비 수 | 시스템에 등록된 전체 장비 수 |
| 온라인 | 정상 통신 중인 장비 수 (녹색) |
| 오프라인 | 통신이 끊어진 장비 수 (회색) |
| 오류 | 비정상 상태 장비 수 (적색) |

요약 대시보드에서는 유형별/상태별 분포를 한눈에 확인할 수 있으며, API를 통해서도 조회 가능하다:

```
GET /api/v1/monitoring/summary
```

### 7.9 문의/민원 관리

관리자(ADMIN) 및 운영자(MANAGER)는 사용자로부터 접수된 문의 및 민원을 조회하고 처리할 수 있다.

#### 문의 목록 조회

1. 좌측 메뉴에서 **[문의 관리]** 또는 관리자 메뉴에서 **[문의/민원]**을 선택한다.
2. 전체 문의 목록이 페이징 형태로 표시된다.
3. 문의 유형, 처리 상태, 날짜 범위 등으로 필터링할 수 있다.

#### 문의 유형

| 문의 유형 | 코드 | 설명 |
|-----------|------|------|
| 계량 문제 | WEIGHING_ISSUE | 계량 오류, 재계량 요청 등 |
| 배차 문제 | DISPATCH_ISSUE | 배차 누락, 배차 수정 요청 등 |
| 시스템 오류 | SYSTEM_ERROR | 화면 오류, 기능 동작 불량 등 |
| 일반 문의 | GENERAL_INQUIRY | 시스템 사용법, 운영 관련 질문 등 |
| 민원 | COMPLAINT | 서비스 불만, 개선 요청 등 |
| 기타 | ETC | 위 분류에 해당하지 않는 문의 |

#### 관련 정보 확인

문의 상세 화면에서 해당 문의와 관련된 배차 및 계량 정보를 확인할 수 있다:

- **관련 배차 정보**: 문의에 연결된 배차 번호, 차량번호, 배차 상태
- **관련 계량 정보**: 문의에 연결된 계량 기록, 총중량/공차중량/순중량, 계량 상태

#### 처리자 메모 작성

관리자 또는 운영자는 문의에 대한 처리 내역을 메모로 기록할 수 있다:

1. 문의 상세 화면에서 **[메모 작성]** 영역을 찾는다.
2. 처리 내용, 조치 사항, 회신 내역 등을 입력한다.
3. **[저장]** 버튼을 클릭하면 메모가 기록되며, 작성자와 작성일시가 자동으로 저장된다.

> **참고**: 처리자 메모는 내부 관리용으로, 문의를 접수한 사용자에게는 표시되지 않는다.

### 7.10 통계/보고서 관리

통계 및 보고서 관리 기능에서는 계량 실적 데이터를 기간별, 조건별로 집계하여 조회하고 엑셀 파일로 내보낼 수 있다.

#### 통계 조회

웹 관리 화면의 **[통계/보고서]** 메뉴에서 다음 기준으로 통계를 조회할 수 있다:

**기간별 조회**:

| 조회 유형 | 설명 | API 엔드포인트 |
|-----------|------|----------------|
| 일별 통계 | 지정 기간 내 일자별 계량 실적 집계 | `GET /api/v1/statistics/daily` |
| 월별 통계 | 지정 기간 내 월별 계량 실적 집계 | `GET /api/v1/statistics/monthly` |

**필터 조건**:

| 필터 항목 | 설명 |
|-----------|------|
| 시작일 / 종료일 | 조회 기간 설정 |
| 운송사 | 특정 운송사 기준 필터링 |
| 품목 | 특정 품목(부산물/폐기물/부재료/반출/일반) 기준 필터링 |

#### 요약 통계

요약 통계(`GET /api/v1/statistics/summary`)에서는 조회 기간에 대한 핵심 지표를 한눈에 확인할 수 있다:

| 요약 항목 | 설명 |
|-----------|------|
| 총 건수 | 조회 기간 내 전체 계량 건수 |
| 총 중량 | 조회 기간 내 전체 순중량 합계 |
| 품목별 분포 | 품목 유형별 계량 건수 및 중량 비율 |
| 운송사별 분포 | 운송사별 계량 건수 및 중량 비율 |

#### 엑셀 내보내기

통계 데이터를 엑셀(xlsx) 파일로 다운로드할 수 있다:

1. 통계 조회 화면에서 원하는 기간 및 필터 조건을 설정한다.
2. **[엑셀 내보내기]** 버튼을 클릭한다.
3. 다음 시트가 포함된 xlsx 파일이 다운로드된다:

| 시트명 | 내용 |
|--------|------|
| 일별 통계 | 일자별 계량 건수, 총중량, 순중량 집계 |
| 월별 통계 | 월별 계량 건수, 총중량, 순중량 집계 |
| 전체 데이터 | 조회 조건에 해당하는 전체 계량 기록 상세 |

> **참고**: 엑셀 내보내기 API는 `GET /api/v1/statistics/export`이며, 조회 조건을 쿼리 파라미터로 전달한다.

### 7.11 즐겨찾기 관리

사용자별 즐겨찾기 기능을 통해 자주 접근하는 메뉴, 배차, 차량, 운송사, 계량대를 빠르게 조회할 수 있다.

#### 즐겨찾기 유형

| 유형 | 코드 | 설명 |
|------|------|------|
| 메뉴 | MENU | 자주 사용하는 메뉴 페이지 |
| 배차 | DISPATCH | 자주 조회하는 배차 정보 |
| 차량 | VEHICLE | 자주 조회하는 차량 정보 |
| 운송사 | COMPANY | 자주 조회하는 운송사 정보 |
| 계량대 | SCALE | 자주 조회하는 계량대 정보 |

#### 즐겨찾기 등록/해제

- 각 목록 화면에서 항목 옆의 **별표** 아이콘을 클릭하면 즐겨찾기에 추가된다.
- 이미 등록된 항목의 별표 아이콘을 다시 클릭하면 즐겨찾기에서 해제된다.
- 즐겨찾기 토글 API(`POST /api/v1/favorites/toggle`)를 통해 추가/해제를 한 번에 처리할 수 있다.

#### 즐겨찾기 제한

- 사용자당 최대 **20개**까지 즐겨찾기를 등록할 수 있다.
- 20개를 초과하여 추가하려고 하면 안내 메시지가 표시되며, 기존 항목을 해제한 후 추가해야 한다.

#### 즐겨찾기 순서 변경

즐겨찾기 목록의 표시 순서를 변경할 수 있다:

1. 즐겨찾기 패널에서 항목을 드래그하여 원하는 위치로 이동한다.
2. 변경된 순서는 자동으로 저장된다.

> **참고**: 즐겨찾기는 사용자별로 독립적으로 관리되며, 다른 사용자의 즐겨찾기에 영향을 주지 않는다.

---

## 8. 장비 관리

### 8.1 LPR 카메라 관리

#### LPR 카메라 구성 정보

| 항목 | 설정 |
|------|------|
| 통신 프로토콜 | TCP |
| 연동 방식 | 계량대 CS 프로그램에서 직접 통신 |
| 트리거 | LiDAR/레이더 센서 차량 감지 시 촬영 명령 |
| 출력 데이터 | 촬영 이미지 + 1차 인식 차량번호 |
| 이미지 저장 | NAS 경로 (90일 보관) |

#### LPR 인식률 모니터링

```sql
-- 일별 LPR 인식률 조회
SELECT DATE(created_at) AS dt,
       COUNT(*) AS total,
       COUNT(CASE WHEN ai_confidence >= 0.90 THEN 1 END) AS auto_confirmed,
       COUNT(CASE WHEN ai_confidence < 0.90 AND ai_confidence >= 0.70 THEN 1 END) AS low_confidence,
       COUNT(CASE WHEN ai_confidence < 0.70 OR ai_confidence IS NULL THEN 1 END) AS failed,
       ROUND(COUNT(CASE WHEN ai_confidence >= 0.90 THEN 1 END) * 100.0 / NULLIF(COUNT(*), 0), 2) AS auto_rate_pct
FROM tb_weighing
WHERE weighing_mode = 'LPR_AUTO'
  AND created_at >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY DATE(created_at)
ORDER BY dt DESC;
```

목표 인식률: 95% 이상. 인식률이 90% 이하로 떨어지면 다음을 점검한다:
- LPR 카메라 렌즈 오염 여부
- 보조 조명 정상 작동 여부 (야간)
- 카메라 각도 및 초점 상태
- AI 엔진 응답 시간

### 8.2 LiDAR 센서 관리

| 항목 | 설정 |
|------|------|
| 통신 프로토콜 | TCP/UDP |
| 역할 | 차량 진입 감지 -> LPR 촬영 트리거 |
| 감지 범위 | 계량대 진입로 (설치 위치에 따라 설정) |
| 중복 감지 방지 | 최소 10초 간격 |

#### 센서 점검 사항

- 센서 표면 청결 상태 (먼지, 이물질)
- 감지 영역 장애물 확인
- 전원 및 케이블 연결 상태
- 통신 데이터 정상 수신 확인

### 8.3 인디게이터 (RS-232C) 관리

인디게이터는 계량대에서 측정된 중량값을 표시하고 계량대 CS 프로그램에 전송하는 장치이다.

#### 통신 설정

| 항목 | 설정값 |
|------|--------|
| 포트 | COM 포트 (예: COM1, COM3) |
| Baud Rate | 9600 (장비에 따라 변경) |
| Data Bits | 8 |
| Parity | None |
| Stop Bits | 1 |
| Flow Control | None |
| 타임아웃 | 3초 |
| 재시도 | 3회 |

#### 인디게이터 장애 대응

| 증상 | 원인 | 조치 |
|------|------|------|
| 중량값 수신 안됨 | RS-232C 케이블 단선 | 케이블 교체 또는 연결 확인 |
| 불안정한 값 수신 | 접촉 불량 | 커넥터 재연결, 시리얼 컨버터 확인 |
| 통신 타임아웃 | COM 포트 충돌 | 장치 관리자에서 포트 확인 |
| 비정상 데이터 | 통신 설정 불일치 | Baud Rate 등 파라미터 확인 |

```
RS-232C 통신 장애 대응 절차:
1. 계량대 CS 프로그램에서 인디게이터 상태 확인
2. COM 포트 연결 상태 확인 (장치 관리자)
3. 시리얼 케이블 물리적 연결 확인
4. 통신 파라미터(Baud Rate) 일치 확인
5. 시리얼-USB 컨버터 사용 시 드라이버 상태 확인
6. 예비 컨버터로 교체 테스트
7. 해결되지 않으면 인디게이터 제조사 지원 요청
```

### 8.4 전광판 관리

전광판은 계량대 진입 차량에게 OTP 코드 등 안내 정보를 표시한다.

| 항목 | 설정 |
|------|------|
| 통신 | TCP 또는 RS-485 |
| 표시 내용 | OTP 6자리, 차량번호, 안내 메시지 |
| 제어 | 계량대 CS 프로그램에서 송신 |

#### 전광판 점검 사항

- LED 밝기 및 가독성 (주간/야간)
- 통신 연결 상태
- OTP 코드 정상 표시 여부
- 한글 표시 정상 여부

### 8.5 자동 차단기 관리

자동 차단기는 계량대 진입/출입을 물리적으로 제어한다.

| 항목 | 설정 |
|------|------|
| 통신 | TCP 또는 RS-485 |
| 제어 명령 | 개방(OPEN) / 폐쇄(CLOSE) |
| 안전 장치 | 차량 감지 시 폐쇄 방지 (안전 센서) |
| Fallback | 통신 장애 시 수동 개방 가능 |

#### 차단기 비상 조작

통신 장애 등으로 자동 제어가 불가능한 경우:
1. 차단기 제어함의 수동 스위치를 사용하여 개방한다.
2. 수동 모드로 전환하여 차단기를 고정 개방 상태로 유지한다.
3. 장애 원인을 파악하고 해결한 후 자동 모드로 복귀한다.
4. 비상 조작 이력을 기록한다.

---

## 9. 장애 대응

### 9.1 장애 유형별 대응 절차

#### 장애 등급 분류

| 등급 | 정의 | 대응 시간 | 예시 |
|------|------|----------|------|
| Critical (긴급) | 전체 서비스 중단 | 즉시 (30분 이내 복구 착수) | WAS 전체 다운, DB 장애, 네트워크 단절 |
| Major (중대) | 주요 기능 장애 | 1시간 이내 대응 | WAS 1대 다운, LPR 장애, Redis 장애 |
| Minor (경미) | 부분 기능 저하 | 4시간 이내 대응 | 성능 저하, 개별 센서 장애, 알림 발송 실패 |
| Info (정보) | 서비스 영향 없음 | 다음 업무 시간 | 로그 경고, 디스크 사용률 증가 |

#### WAS 서버 장애

```
장애 감지: Nginx 헬스체크 실패 (max_fails=3, fail_timeout=30s)
자동 대응: Nginx가 장애 서버를 upstream에서 자동 제외 (Active-Active)
RTO: < 30초 (자동 failover)

수동 복구 절차:
1. 장애 서버 상태 확인
   $ docker ps -a | grep weighing-api
   $ docker logs weighing-api-1 --tail 100

2. 컨테이너 재시작
   $ docker compose restart weighing-api-1

3. 헬스체크 확인
   $ curl -s http://localhost:8080/actuator/health | python3 -m json.tool

4. 원인 분석
   - 애플리케이션 로그 확인: /data/weighing/logs/
   - JVM 메모리 확인: /actuator/metrics/jvm.memory.used
   - OOM Killer 확인: dmesg | grep -i oom

5. Nginx에서 서버 복귀 확인
   $ curl -s http://localhost/api/v1/health
```

#### 데이터베이스 장애

```
장애 감지: Spring Boot 연결 실패, Prometheus pg_up == 0

PostgreSQL Primary 장애 시 Standby 승격 절차:
RTO: < 30분 (수동 승격)

1. Primary 상태 확인
   $ pg_isready -h 10.x.x.10 -p 5432
   $ sudo systemctl status postgresql-16

2. Primary 복구 시도
   $ sudo systemctl restart postgresql-16
   $ tail -100 /var/lib/pgsql/16/data/log/postgresql-*.log

3. Primary 복구 불가 시 Standby 승격
   -- Standby 서버에서 실행:
   $ pg_ctl promote -D /var/lib/pgsql/16/data

4. 애플리케이션 DB 연결 정보 변경
   -- .env 파일에서 DB_HOST를 Standby IP로 변경
   $ vi /opt/weighing/.env
   DB_HOST=10.x.x.11    # Standby IP로 변경

5. 애플리케이션 재시작
   $ docker compose restart weighing-api-1 weighing-api-2

6. 데이터 정합성 확인
   $ psql -h 10.x.x.11 -U weighing_app -d weighing -c "SELECT COUNT(*) FROM tb_weighing;"

7. 원래 Primary 복구 후 Standby로 재구성
```

#### Redis 장애

```
장애 감지: Spring Boot Redis 연결 실패, redis_up == 0

자동 Fallback:
- Refresh Token 검증: JWT 자체 검증만 수행 (블랙리스트 비활성)
- OTP 세션: DB(tb_otp_session) 직접 조회
RTO: < 10분

수동 복구 절차:
1. Redis 상태 확인
   $ redis-cli -h 10.x.x.20 ping
   $ sudo systemctl status redis

2. Redis 재시작
   $ sudo systemctl restart redis

3. 연결 확인
   $ redis-cli -h 10.x.x.20 -a '<비밀번호>' info server

4. 캐시 워밍업 (필요 시)
   - 기준정보 캐시는 API 호출 시 자동 재적재
   - 활성 세션은 사용자 재로그인 필요
```

#### LPR 장비 장애

```
장애 감지: CS 프로그램에서 LPR 통신 끊김 감지

즉시 대응:
1. 계량대 CS 프로그램에 경고 표시
2. 자동으로 수동 계량 모드 안내
3. 전광판에 "수동 계량 모드" 안내 표시

복구 절차:
1. LPR 카메라 전원 및 네트워크 확인
2. LPR 관리 소프트웨어에서 카메라 상태 확인
3. TCP 연결 테스트
4. 카메라 재시작 (전원 OFF/ON)
5. CS 프로그램에서 LPR 재연결 시도
6. 복구 실패 시 제조사 기술 지원 요청

대체 운영:
- 모바일 OTP 계량으로 전환
- 수동 계량 모드 (터치스크린) 병행
```

#### 네트워크 장애 (계량대-서버 간)

```
장애 감지: CS 프로그램에서 API 서버 통신 실패

자동 대응:
1. 계량대 CS 프로그램이 로컬 캐싱 모드 전환
2. 계량 데이터를 로컬 SQLite에 임시 저장
3. 네트워크 복구 후 자동 동기화
RTO: < 1시간 (자동 동기화)

수동 복구 절차:
1. 네트워크 연결 상태 확인
   $ ping 10.x.x.1 (WAS 서버)
   $ traceroute 10.x.x.1

2. VPN 연결 상태 확인 (해당 시)

3. 네트워크 장비(스위치, 라우터) 확인

4. 네트워크 복구 후 데이터 동기화 상태 확인
   - CS 프로그램의 동기화 대기 건수 확인
   - 동기화 완료 후 서버 데이터 정합성 확인
```

### 9.2 시스템 복구 절차

#### 전체 시스템 복구 순서

시스템 전체 장애 시 다음 순서로 복구한다:

```
1단계: 인프라 복구
  1. 네트워크 장비 확인 및 복구
  2. 서버 하드웨어 확인

2단계: 데이터 계층 복구
  3. PostgreSQL 기동 및 데이터 정합성 확인
  4. Redis 기동 및 연결 확인

3단계: 애플리케이션 복구
  5. Spring Boot WAS #1 기동
  6. WAS #1 헬스체크 확인
  7. Spring Boot WAS #2 기동
  8. WAS #2 헬스체크 확인

4단계: 프론트엔드 및 프록시 복구
  9. Nginx 기동 및 설정 확인
  10. 웹 UI 접근 테스트

5단계: 현장 장비 복구
  11. 계량대 CS 프로그램 기동
  12. LPR/센서/인디게이터 통신 확인
  13. 전광판/차단기 동작 확인

6단계: 검증
  14. E2E 계량 테스트 수행
  15. 로컬 캐시 데이터 동기화 확인
  16. 모니터링 시스템 알림 해제
```

### 9.3 롤백 절차

#### 애플리케이션 롤백

```bash
# 현재 버전 확인
docker images | grep weighing-api

# 이전 버전으로 롤백 (5분 이내 완료)
export ROLLBACK_VERSION="이전_버전_태그"

# 두 WAS를 동시에 롤백
docker compose stop weighing-api-1 weighing-api-2
APP_VERSION=${ROLLBACK_VERSION} docker compose up -d weighing-api-1 weighing-api-2

# 헬스체크 확인
sleep 30
curl -sf http://localhost:8080/actuator/health && echo "WAS#1 OK" || echo "WAS#1 FAIL"
curl -sf http://localhost:8081/actuator/health && echo "WAS#2 OK" || echo "WAS#2 FAIL"
```

#### 데이터베이스 롤백

DB 스키마 변경이 포함된 배포의 롤백은 다음 절차를 따른다:

1. 애플리케이션을 먼저 롤백한다 (이전 버전 이미지 배포).
2. DB 변경 사항의 롤백 SQL을 실행한다 (사전에 준비된 rollback script).
3. 데이터 정합성을 확인한다.

> **주의**: `ddl-auto: none` (운영 환경)이므로 DB 스키마 변경은 수동 마이그레이션으로만 수행된다. 항상 롤백 SQL을 사전에 준비한다.

### 9.4 비상 연락망

| 구분 | 담당 | 연락처 | 대응 범위 |
|------|------|--------|----------|
| 시스템 운영 | 시스템 관리자 (1차) | 내선 XXXX | 서버, DB, 네트워크 |
| 시스템 운영 | 시스템 관리자 (2차) | 내선 XXXX | 서버, DB, 네트워크 |
| 애플리케이션 | 개발팀 | 내선 XXXX | SW 장애, 배포 |
| 현장 장비 | DMES팀 | 내선 XXXX | LPR, 센서, 인디게이터 |
| 네트워크 | 인프라팀 | 내선 XXXX | 네트워크 장비, VPN |
| DB 전문가 | DBA | 내선 XXXX | DB 복구, 성능 이슈 |
| LPR 제조사 | 외부 업체 | 연락처 XXXX | LPR 하드웨어 장애 |
| 인디게이터 제조사 | 외부 업체 | 연락처 XXXX | 계량 장비 하드웨어 |

> **참고**: 비상 연락망은 최소 분기 1회 연락처 유효성을 검증하고 갱신한다.

---

## 10. 백업 및 복구

### 10.1 백업 정책

| 대상 | 방식 | 주기 | 보관 기간 | 저장 위치 |
|------|------|------|----------|----------|
| PostgreSQL 전체 | pg_dump (Custom) | 매일 02:00 | 30일 | /data/backup/postgresql/ |
| PostgreSQL WAL | WAL 아카이브 | 실시간 | 7일 | /data/pg_archive/ |
| Redis RDB | RDB Snapshot | 6시간마다 | 3일 | /var/lib/redis/ |
| LPR 이미지 | NAS rsync | 매일 03:00 | 90일 | NAS 스토리지 |
| 애플리케이션 로그 | ELK 수집 | 실시간 | 90일 | Elasticsearch |
| Nginx 설정 | Git 관리 | 변경 시 | 무기한 | GitLab |
| Docker Compose | Git 관리 | 변경 시 | 무기한 | GitLab |
| .env (암호화) | 수동 백업 | 변경 시 | 무기한 | 별도 금고 보관 |

### 10.2 자동 백업 설정

#### PostgreSQL 자동 백업 (crontab)

```bash
# crontab -l (weighing-admin 계정)

# PostgreSQL 전체 백업 (매일 02:00)
0 2 * * * /opt/weighing/scripts/pg_backup.sh >> /var/log/weighing/backup.log 2>&1

# Redis RDB 백업 복사 (매 6시간)
0 */6 * * * cp /var/lib/redis/dump.rdb /data/backup/redis/dump_$(date +\%Y\%m\%d_\%H\%M).rdb 2>&1

# LPR 이미지 NAS 동기화 (매일 03:00)
0 3 * * * rsync -avz --delete /data/weighing/lpr-images/ /mnt/nas/weighing/lpr-images/ >> /var/log/weighing/lpr-sync.log 2>&1

# 오래된 백업 정리 (매주 일요일 04:00)
0 4 * * 0 /opt/weighing/scripts/cleanup_old_backups.sh >> /var/log/weighing/cleanup.log 2>&1
```

#### 백업 검증 스크립트

```bash
#!/bin/bash
# /opt/weighing/scripts/verify_backup.sh
# 주 1회 백업 복원 테스트를 수행한다

LATEST_BACKUP=$(ls -t /data/backup/postgresql/weighing_*.sql.gz | head -1)
TEST_DB="weighing_backup_test"

echo "[$(date)] 백업 검증 시작: ${LATEST_BACKUP}"

# 테스트 DB 생성 및 복원
dropdb -h localhost -U postgres --if-exists ${TEST_DB}
createdb -h localhost -U postgres ${TEST_DB}
pg_restore -h localhost -U postgres -d ${TEST_DB} ${LATEST_BACKUP}

if [ $? -eq 0 ]; then
    # 주요 테이블 건수 확인
    psql -h localhost -U postgres -d ${TEST_DB} -c "
        SELECT 'tb_user' AS tbl, COUNT(*) AS cnt FROM tb_user
        UNION ALL SELECT 'tb_dispatch', COUNT(*) FROM tb_dispatch
        UNION ALL SELECT 'tb_weighing', COUNT(*) FROM tb_weighing
        UNION ALL SELECT 'tb_vehicle', COUNT(*) FROM tb_vehicle;
    "
    echo "[$(date)] 백업 검증 성공"
else
    echo "[$(date)] 백업 검증 실패!" >&2
fi

# 테스트 DB 삭제
dropdb -h localhost -U postgres ${TEST_DB}
```

### 10.3 복구 절차

#### PITR (Point-in-Time Recovery)

WAL 아카이브를 이용하여 특정 시점으로 복구할 수 있다.

```bash
# 1. PostgreSQL 중지
sudo systemctl stop postgresql-16

# 2. 데이터 디렉토리 백업
sudo mv /var/lib/pgsql/16/data /var/lib/pgsql/16/data_backup

# 3. 기본 백업에서 복원
sudo -u postgres pg_basebackup -D /var/lib/pgsql/16/data -R

# 4. recovery.conf (또는 postgresql.auto.conf)에 복구 대상 시점 설정
echo "recovery_target_time = '2026-01-29 14:00:00+09'" >> /var/lib/pgsql/16/data/postgresql.auto.conf
echo "restore_command = 'cp /data/pg_archive/%f %p'" >> /var/lib/pgsql/16/data/postgresql.auto.conf

# 5. PostgreSQL 시작 (복구 모드)
sudo systemctl start postgresql-16

# 6. 복구 완료 후 타임라인 확인
sudo -u postgres psql -c "SELECT pg_is_in_recovery();"
# 결과: f (false) -> 복구 완료, Primary로 전환됨
```

### 10.4 재해 복구 계획 (DR)

#### RPO / RTO 목표

| 지표 | 목표값 | 달성 방법 |
|------|--------|----------|
| RPO (Recovery Point Objective) | 1시간 이내 | WAL 실시간 아카이브 |
| RTO (Recovery Time Objective) | 1시간 이내 | Standby DB + Docker 이미지 |

#### DR 시나리오

| 시나리오 | 대응 | RTO |
|---------|------|-----|
| 단일 WAS 장애 | Nginx 자동 failover | < 30초 |
| WAS 전체 장애 | Docker 이미지로 재배포 | < 10분 |
| DB Primary 장애 | Standby 수동 승격 | < 30분 |
| Redis 장애 | Redis 재시작 + DB Fallback | < 10분 |
| 서버실 화재/침수 | 오프사이트 백업에서 신규 서버 구축 | < 24시간 |
| 전체 시스템 장애 | 수동 운영 전환 (기존 방식 병행) | 즉시 |

#### DR 훈련

- **주기**: 반기 1회
- **범위**: DB Standby 승격, 백업 복원, 수동 운영 전환
- **기록**: 훈련 결과를 문서화하고 개선 사항을 반영

---

## 11. 성능 관리

### 11.1 성능 지표 및 목표

| 지표 | 목표값 | 측정 방법 |
|------|--------|----------|
| LPR 인식 -> 자동 계량 완료 | < 3초 (E2E) | 애플리케이션 로그 타임스탬프 |
| API 응답 시간 p50 | < 200ms | Prometheus + Spring Actuator |
| API 응답 시간 p95 | < 500ms | Prometheus + Spring Actuator |
| API 응답 시간 p99 | < 1,000ms | Prometheus + Spring Actuator |
| 웹 FCP (First Contentful Paint) | < 2초 | Lighthouse |
| 웹 LCP (Largest Contentful Paint) | < 3초 | Lighthouse |
| 동시 웹 접속자 | 50명 이상 | 부하 테스트 |
| 동시 모바일 접속자 | 200명 이상 | 부하 테스트 |
| 일일 계량 처리 건수 | 500건 이상 | DB 집계 |
| API TPS (평상시) | 100 TPS | Prometheus |
| API TPS (피크) | 300 TPS | Prometheus |

### 11.2 성능 모니터링 방법

#### API 응답 시간 모니터링

```
Grafana 대시보드: API Performance
패널:
  - Request Rate (req/s) by endpoint
  - Latency p50 / p95 / p99 by endpoint
  - Error Rate (4xx, 5xx) by endpoint
  - Active Connections
```

#### JVM 메모리 모니터링

```bash
# Actuator를 통한 JVM 메트릭 확인
curl -s http://localhost:8080/actuator/metrics/jvm.memory.used | python3 -m json.tool
curl -s http://localhost:8080/actuator/metrics/jvm.gc.pause | python3 -m json.tool

# 주요 감시 항목:
# - jvm.memory.used: Heap 사용량
# - jvm.gc.pause: GC 일시정지 시간
# - jvm.threads.live: 활성 스레드 수
```

#### DB 커넥션 풀 모니터링

```bash
# HikariCP 메트릭 확인
curl -s http://localhost:8080/actuator/metrics/hikaricp.connections.active | python3 -m json.tool
curl -s http://localhost:8080/actuator/metrics/hikaricp.connections.pending | python3 -m json.tool

# 주요 감시 항목:
# - hikaricp.connections.active: 활성 연결 수 (max: 30)
# - hikaricp.connections.pending: 대기 중인 연결 요청
# - hikaricp.connections.timeout: 연결 타임아웃 발생 수
```

### 11.3 최적화 가이드

#### Redis 캐시 최적화

현재 캐싱 대상:

| 캐시 대상 | 키 패턴 | TTL | 무효화 조건 |
|----------|---------|-----|-----------|
| 기준정보 (운송사) | cache:company:* | 5분 | 운송사 정보 변경 시 |
| 기준정보 (차량) | cache:vehicle:* | 5분 | 차량 정보 변경 시 |
| 배차 목록 | cache:dispatch:* | 1분 | 배차 등록/변경 시 |
| 공통 코드 | cache:code:* | 30분 | 코드 변경 시 |

캐시 적중률이 80% 미만이면 TTL 조정 또는 캐시 전략을 재검토한다.

```bash
# Redis 캐시 적중률 확인
redis-cli -h 10.x.x.20 -a '<비밀번호>' info stats | grep keyspace
# keyspace_hits / (keyspace_hits + keyspace_misses) = 적중률
```

#### DB 쿼리 최적화

```sql
-- 인덱스 사용률 확인
SELECT schemaname, tablename, indexrelname, idx_scan, idx_tup_read, idx_tup_fetch
FROM pg_stat_user_indexes
ORDER BY idx_scan ASC
LIMIT 20;

-- 사용되지 않는 인덱스 확인 (제거 후보)
SELECT schemaname, tablename, indexrelname
FROM pg_stat_user_indexes
WHERE idx_scan = 0
  AND schemaname = 'public';

-- 테이블별 순차 스캔 vs 인덱스 스캔 비율
SELECT relname,
       seq_scan, seq_tup_read,
       idx_scan, idx_tup_fetch,
       CASE WHEN (seq_scan + idx_scan) > 0
            THEN ROUND(idx_scan * 100.0 / (seq_scan + idx_scan), 2)
            ELSE 0 END AS idx_scan_pct
FROM pg_stat_user_tables
WHERE (seq_scan + idx_scan) > 0
ORDER BY seq_scan DESC
LIMIT 20;
```

#### Nginx 성능 튜닝

```nginx
# 운영 환경 튜닝 포인트

# Worker 프로세스 (CPU 코어 수에 맞춤)
worker_processes auto;

# 연결 수 (ulimit -n 값 이하)
worker_connections 2048;

# 파일 전송 최적화
sendfile on;
tcp_nopush on;
tcp_nodelay on;

# 버퍼 설정
proxy_buffer_size 128k;
proxy_buffers 4 256k;
proxy_busy_buffers_size 256k;

# Keepalive
keepalive_timeout 65;
upstream weighing_api {
    keepalive 32;   # upstream keepalive 연결 수
}
```

---

## 12. 운영 체크리스트

### 12.1 일일 점검 항목

매일 업무 시작 시 (08:00) 다음 항목을 점검한다.

| No. | 점검 항목 | 점검 방법 | 정상 기준 |
|-----|----------|----------|----------|
| D-01 | WAS 서버 상태 | Actuator /health 확인 | 모든 인스턴스 UP |
| D-02 | DB 연결 상태 | pg_isready 실행 | 응답 정상 |
| D-03 | Redis 연결 상태 | redis-cli ping | PONG 응답 |
| D-04 | Nginx 상태 | systemctl status nginx | active (running) |
| D-05 | 디스크 사용률 | df -h | < 80% |
| D-06 | 야간 백업 결과 | backup.log 확인 | 성공 로그 존재 |
| D-07 | 에러 로그 확인 | Kibana ERROR 검색 | 비정상 에러 없음 |
| D-08 | 장비 상태 대시보드 | 웹 장비 모니터링 | 모든 장비 ONLINE |
| D-09 | LPR 인식률 | 전일 통계 확인 | >= 95% |
| D-10 | 전일 계량 건수 | 대시보드 확인 | 정상 범위 내 |

#### 일일 점검 스크립트

```bash
#!/bin/bash
# /opt/weighing/scripts/daily_check.sh

echo "=========================================="
echo " 부산 스마트 계량 시스템 일일 점검"
echo " $(date '+%Y-%m-%d %H:%M:%S')"
echo "=========================================="

# WAS 상태
echo ""
echo "[D-01] WAS 서버 상태"
for port in 8080 8081; do
    STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:${port}/actuator/health)
    if [ "$STATUS" = "200" ]; then
        echo "  WAS (${port}): OK"
    else
        echo "  WAS (${port}): FAIL (HTTP ${STATUS})"
    fi
done

# DB 상태
echo ""
echo "[D-02] PostgreSQL 상태"
pg_isready -h ${DB_HOST} -p 5432 && echo "  DB: OK" || echo "  DB: FAIL"

# Redis 상태
echo ""
echo "[D-03] Redis 상태"
redis-cli -h ${REDIS_HOST} -a "${REDIS_PASSWORD}" ping 2>/dev/null && echo "  Redis: OK" || echo "  Redis: FAIL"

# 디스크 사용률
echo ""
echo "[D-05] 디스크 사용률"
df -h | grep -E '^/dev/' | awk '{print "  " $6 ": " $5}'

# 백업 결과
echo ""
echo "[D-06] 최근 백업"
ls -lah /data/backup/postgresql/ | tail -3

# 에러 로그 건수 (최근 24시간)
echo ""
echo "[D-07] 최근 24시간 에러 로그 건수"
if [ -f /data/weighing/logs/weighing-api.json ]; then
    ERROR_COUNT=$(grep -c '"level":"ERROR"' /data/weighing/logs/weighing-api.json 2>/dev/null || echo "0")
    echo "  ERROR 건수: ${ERROR_COUNT}"
fi

echo ""
echo "=========================================="
echo " 점검 완료"
echo "=========================================="
```

### 12.2 주간 점검 항목

매주 월요일 오전에 수행한다.

| No. | 점검 항목 | 점검 방법 | 정상 기준 |
|-----|----------|----------|----------|
| W-01 | DB 테이블 통계 갱신 | ANALYZE 실행 | 정상 완료 |
| W-02 | 슬로우 쿼리 확인 | pg_stat_statements 조회 | 3초 초과 쿼리 없음 |
| W-03 | Redis 메모리 추이 | Grafana Redis 대시보드 | < 80% |
| W-04 | 로그 디스크 사용량 | du -sh /data/weighing/logs | < 70% |
| W-05 | SSL 인증서 만료일 | openssl x509 확인 | 잔여 30일 이상 |
| W-06 | Docker 이미지 정리 | docker image prune | 사용하지 않는 이미지 제거 |
| W-07 | 주간 LPR 인식률 통계 | DB 집계 쿼리 | >= 95% |
| W-08 | 계정 잠금 이력 확인 | 감사 로그 조회 | 비정상 패턴 없음 |
| W-09 | Prometheus 알림 이력 | Alertmanager 확인 | Critical 알림 원인 해소 |
| W-10 | 백업 복원 검증 | verify_backup.sh 실행 | 복원 성공 |

### 12.3 월간 점검 항목

매월 첫째 주 수행한다.

| No. | 점검 항목 | 점검 방법 | 정상 기준 |
|-----|----------|----------|----------|
| M-01 | OS 보안 패치 | dnf update --security | 최신 패치 적용 |
| M-02 | DB VACUUM 수행 | VACUUM ANALYZE | 정상 완료 |
| M-03 | 만료 OTP 세션 정리 | 90일 이상 경과 레코드 삭제 | 정리 완료 |
| M-04 | 사용자 계정 감사 | 비활성 계정, 퇴사자 확인 | 불필요 계정 비활성화 |
| M-05 | 성능 추이 분석 | Grafana 월간 대시보드 | 목표 범위 내 |
| M-06 | 로그 보관 정책 확인 | 보관 기간 초과 로그 삭제 | 정책 준수 |
| M-07 | 장비 물리 점검 | 현장 장비 외관/청결 점검 | 이상 없음 |
| M-08 | 비상 연락망 갱신 | 연락처 유효성 확인 | 최신 상태 유지 |

#### 월간 OTP 세션 정리 쿼리

```sql
-- 90일 이상 경과한 OTP 세션 삭제
DELETE FROM tb_otp_session
WHERE created_at < NOW() - INTERVAL '90 days';

-- 삭제 건수 확인
-- DELETE n (n건 삭제됨)
```

### 12.4 분기 점검 항목

분기별(3월, 6월, 9월, 12월) 수행한다.

| No. | 점검 항목 | 점검 방법 | 정상 기준 |
|-----|----------|----------|----------|
| Q-01 | DR 훈련 수행 | DB Standby 승격 테스트 | RTO 목표 이내 복구 |
| Q-02 | 보안 취약점 점검 | OWASP 체크리스트 검토 | 미조치 취약점 없음 |
| Q-03 | 암호화 키 점검 | 키 유효성 및 강도 확인 | 정책 준수 |
| Q-04 | 부하 테스트 수행 | JMeter 등으로 부하 테스트 | 성능 목표 충족 |
| Q-05 | 계량대 교정 확인 | 교정 이력 및 만료일 확인 | 유효 교정 유지 |
| Q-06 | 문서 갱신 | 운영 매뉴얼 최신화 | 현행화 완료 |
| Q-07 | 비상 연락망 검증 | 연락 테스트 수행 | 전원 연락 가능 |
| Q-08 | 용량 계획 검토 | 디스크/메모리/CPU 추이 | 6개월 이내 부족 예상 없음 |

---

## 13. 부록

### 13.1 API 엔드포인트 목록

#### 인증 API

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| POST | /api/v1/auth/login | ID/PW 로그인 | 불필요 |
| POST | /api/v1/auth/login/otp | OTP 기반 로그인 (모바일) | 불필요 |
| POST | /api/v1/auth/refresh | Access Token 갱신 | Refresh Token |
| POST | /api/v1/auth/logout | 로그아웃 | 필요 |

#### OTP API

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| POST | /api/v1/otp/generate | OTP 생성 (CS 프로그램) | Internal Key |
| POST | /api/v1/otp/verify | OTP 검증 (모바일) | 불필요 |

#### 배차관리 API

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| GET | /api/v1/dispatches | 배차 목록 조회 | 필요 |
| POST | /api/v1/dispatches | 배차 등록 | ADMIN, MANAGER |
| GET | /api/v1/dispatches/{id} | 배차 상세 조회 | 필요 |
| PUT | /api/v1/dispatches/{id} | 배차 수정 | ADMIN, MANAGER |
| DELETE | /api/v1/dispatches/{id} | 배차 삭제 | ADMIN |
| GET | /api/v1/dispatches/my | 내 배차 목록 | DRIVER |

#### 계량관리 API

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| POST | /api/v1/weighings | 계량 시작 | 필요 |
| PUT | /api/v1/weighings/{id}/complete | 계량 완료 처리 | 필요 |
| PUT | /api/v1/weighings/{id}/re-weigh | 재계량 처리 | 필요 |
| GET | /api/v1/weighings | 계량 실적 목록 | 필요 |
| GET | /api/v1/weighings/{id} | 계량 상세 조회 | 필요 |
| GET | /api/v1/weighings/realtime | 실시간 계량 현황 (WebSocket) | 필요 |
| GET | /api/v1/weighings/statistics | 계량 통계 | 필요 |

#### 전자 계량표 API

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| GET | /api/v1/slips/{weighingId} | 전자 계량표 조회 | 필요 |
| POST | /api/v1/slips/{slipId}/share | 계량표 공유 (카카오/SMS) | 필요 |
| GET | /api/v1/slips/history | 계량표 이력 조회 | 필요 |

#### 출문관리 API

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| GET | /api/v1/gate-passes | 출문 목록 조회 | ADMIN, MANAGER |
| POST | /api/v1/gate-passes | 출문 처리 | MANAGER |
| PUT | /api/v1/gate-passes/{id} | 출문 상태 변경 | MANAGER |

#### 기준정보 API

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| GET | /api/v1/master/companies | 운송사 목록 | 필요 |
| POST | /api/v1/master/companies | 운송사 등록 | ADMIN |
| GET | /api/v1/master/vehicles | 차량 목록 | 필요 |
| POST | /api/v1/master/vehicles | 차량 등록 | ADMIN |
| GET | /api/v1/master/scales | 계량대 목록 | 필요 |
| GET | /api/v1/master/codes/{group} | 공통 코드 조회 | 필요 |

#### 알림 API

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| GET | /api/v1/notifications | 알림 목록 | 필요 |
| PUT | /api/v1/notifications/{id}/read | 알림 읽음 처리 | 필요 |
| POST | /api/v1/notifications/push/register | FCM 토큰 등록 | 필요 |

#### 사용자 관리 API

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| POST | /api/v1/users | 사용자 생성 | ADMIN |
| GET | /api/v1/users | 사용자 목록 | ADMIN, MANAGER |
| GET | /api/v1/users/{id} | 사용자 조회 | ADMIN, MANAGER |
| PATCH | /api/v1/users/{id}/toggle-active | 활성/비활성 토글 | ADMIN |
| POST | /api/v1/users/{id}/unlock | 계정 잠금 해제 | ADMIN |
| PATCH | /api/v1/users/{id}/role | 역할 변경 | ADMIN |
| POST | /api/v1/users/{id}/reset-password | 비밀번호 초기화 | ADMIN |
| DELETE | /api/v1/users/{id} | 사용자 삭제 | ADMIN |

#### 문의/통화 API

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| GET | /api/v1/inquiries/contacts | 문의 연락처 목록 | 필요 |
| POST | /api/v1/inquiries/call-log | 통화 이력 기록 | 필요 |
| GET | /api/v1/inquiries/call-log | 통화 이력 조회 | ADMIN, MANAGER |
| GET | /api/v1/inquiries/call-log/my | 내 통화 이력 조회 | 필요 |

#### 문의/민원 관리 API

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| GET | /api/v1/inquiries | 전체 문의 목록 조회 (페이징) | ADMIN, MANAGER |
| GET | /api/v1/inquiries/{id} | 문의 상세 조회 | ADMIN, MANAGER |
| POST | /api/v1/inquiries/{id}/memo | 처리자 메모 작성 | ADMIN, MANAGER |

#### 마이페이지 API

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| GET | /api/v1/mypage | 내 프로필 조회 | 필요 |
| PUT | /api/v1/mypage/profile | 프로필 수정 | 필요 |
| PUT | /api/v1/mypage/password | 비밀번호 변경 | 필요 |
| PUT | /api/v1/mypage/notifications | 알림 설정 변경 | 필요 |

#### 즐겨찾기 API

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| GET | /api/v1/favorites | 즐겨찾기 목록 조회 | 필요 |
| GET | /api/v1/favorites/type/{type} | 유형별 즐겨찾기 (DISPATCH, COMPANY, VEHICLE) | 필요 |
| POST | /api/v1/favorites | 즐겨찾기 추가 | 필요 |
| POST | /api/v1/favorites/toggle | 즐겨찾기 토글 | 필요 |
| GET | /api/v1/favorites/check | 즐겨찾기 여부 확인 | 필요 |
| PUT | /api/v1/favorites/reorder | 즐겨찾기 순서 변경 | 필요 |
| DELETE | /api/v1/favorites/{id} | 즐겨찾기 삭제 | 필요 |

#### 공지사항 API

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| GET | /api/v1/notices | 게시된 공지사항 목록 | 필요 |
| GET | /api/v1/notices/{id} | 공지사항 상세 | 필요 |
| GET | /api/v1/notices/pinned | 고정 공지사항 목록 | 필요 |
| GET | /api/v1/notices/category/{category} | 카테고리별 조회 | 필요 |
| GET | /api/v1/notices/search | 공지사항 검색 | 필요 |
| GET | /api/v1/notices/admin | 전체 공지사항 목록 (발행/미발행 포함) | ADMIN |
| POST | /api/v1/notices | 공지사항 등록 | ADMIN |
| PUT | /api/v1/notices/{id} | 공지사항 수정 | ADMIN |
| DELETE | /api/v1/notices/{id} | 공지사항 삭제 | ADMIN |
| PATCH | /api/v1/notices/{id}/publish | 게시/미게시 전환 | ADMIN |
| PATCH | /api/v1/notices/{id}/pin | 고정/해제 전환 | ADMIN |

#### FAQ 관리 API

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| GET | /api/v1/help/faqs | FAQ 목록 조회 | 불필요 |
| GET | /api/v1/help/faqs/{id} | FAQ 상세 | 불필요 |
| GET | /api/v1/help/faqs/category/{category} | 카테고리별 FAQ | 불필요 |
| GET | /api/v1/help/faqs/admin | FAQ 전체 목록 (관리용) | ADMIN |
| POST | /api/v1/help/faqs | FAQ 등록 | ADMIN |
| PUT | /api/v1/help/faqs/{id} | FAQ 수정 | ADMIN |
| DELETE | /api/v1/help/faqs/{id} | FAQ 삭제 | ADMIN |

#### 시스템 설정 API

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| GET | /api/v1/admin/settings | 전체 시스템 설정 조회 | ADMIN |
| GET | /api/v1/admin/settings/category/{category} | 카테고리별 설정 조회 | ADMIN |
| PUT | /api/v1/admin/settings/{id} | 개별 설정 수정 | ADMIN |
| PUT | /api/v1/admin/settings/bulk | 설정 일괄 수정 | ADMIN |

#### 장비 모니터링 API

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| GET | /api/v1/monitoring/devices | 전체 장비 상태 조회 | 필요 |
| GET | /api/v1/monitoring/devices/type/{deviceType} | 장비 유형별 조회 | 필요 |
| GET | /api/v1/monitoring/devices/{deviceId} | 개별 장비 상태 | 필요 |
| PUT | /api/v1/monitoring/devices/{deviceId}/status | 장비 상태 갱신 | ADMIN, MANAGER |
| GET | /api/v1/monitoring/summary | 장비 건강 요약 | 필요 |
| POST | /api/v1/monitoring/health-check | 장비 헬스체크 트리거 | ADMIN |

#### 통계 API (보완)

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| GET | /api/v1/statistics/daily | 일별 통계 | 필요 |
| GET | /api/v1/statistics/monthly | 월별 통계 | 필요 |
| GET | /api/v1/statistics/summary | 요약 통계 | 필요 |
| GET | /api/v1/statistics/export | Excel 내보내기 | 필요 |

#### 대시보드 API (보완)

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| GET | /api/v1/dashboard/summary | 금일 계량 요약 (총건수, 진행중, 완료) | 필요 |
| GET | /api/v1/dashboard/company-stats | 업체별 계량 통계 | 필요 |

#### 출문관리 API (보완)

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| GET | /api/v1/gate-passes | 출문 목록 조회 | ADMIN, MANAGER |
| GET | /api/v1/gate-passes/{id} | 출문 상세 | ADMIN, MANAGER |
| GET | /api/v1/gate-passes?status= | 상태별 조회 (기본 PENDING) | ADMIN, MANAGER |
| POST | /api/v1/gate-passes | 출문 요청 생성 | ADMIN, MANAGER |
| PUT | /api/v1/gate-passes/{id}/pass | 출문 승인 | ADMIN, MANAGER |
| PUT | /api/v1/gate-passes/{id}/reject | 출문 반려 | ADMIN, MANAGER |

#### LPR API

| Method | Endpoint | 설명 | 인증 |
|--------|----------|------|------|
| POST | /api/v1/lpr/capture | LPR 촬영 이벤트 등록 | Internal Key |
| POST | /api/v1/lpr/verify | AI 차량번호 검증 | Internal Key |
| POST | /api/v1/lpr/{captureId}/match | 배차 매칭 처리 | Internal Key |
| GET | /api/v1/lpr/{captureId} | 촬영 이벤트 상세 | 필요 |
| GET | /api/v1/lpr/scale/{scaleId}/latest | 계량대별 최근 촬영 | 필요 |

### 13.2 환경 변수 전체 목록

| 변수명 | 필수 | 설명 | 예시 값 |
|--------|:----:|------|---------|
| DB_HOST | O | PostgreSQL 호스트 | 10.x.x.10 |
| DB_PORT | X | PostgreSQL 포트 (기본 5432) | 5432 |
| DB_NAME | O | 데이터베이스명 | weighing |
| DB_USERNAME | O | DB 사용자 | weighing_app |
| DB_PASSWORD | O | DB 비밀번호 | (보안값) |
| REDIS_HOST | O | Redis 호스트 | 10.x.x.20 |
| REDIS_PORT | X | Redis 포트 (기본 6379) | 6379 |
| REDIS_PASSWORD | O | Redis 비밀번호 | (보안값) |
| JWT_SECRET | O | JWT 서명 키 (Base64) | (보안값) |
| AES_SECRET_KEY | O | AES-256 암호화 키 (Base64) | (보안값) |
| CORS_ORIGIN_WEB | O | 허용 CORS Origin | https://weighing.factory.internal |
| CORS_ORIGIN_MOBILE | X | 모바일 CORS Origin | http://localhost:8081 |
| API_INTERNAL_KEY | O | CS 프로그램 내부 API 키 | (보안값) |
| SPRING_PROFILES_ACTIVE | O | 활성 프로파일 | prod |
| APP_VERSION | X | 애플리케이션 버전 태그 | 1.0.0 |

### 13.3 데이터베이스 ERD

```
tb_company (운송사)                  tb_vehicle (차량)
+-----------------+                 +------------------+
| company_id (PK) |<---+       +--->| vehicle_id (PK)  |
| company_name    |    |       |    | plate_number (UQ)|
| company_type    |    |       |    | company_id (FK)  |---+
| contact_phone   |    |       |    | vehicle_type     |   |
| is_active       |    |       |    | max_load_weight  |   |
+-----------------+    |       |    | is_active        |   |
        |              |       |    +------------------+   |
        |              |       |                           |
        v              |       |                           |
tb_user (사용자)        |       |                           |
+-----------------+    |       |                           |
| user_id (PK)    |    |       |                           |
| company_id (FK) |----+       |                           |
| user_name       |            |                           |
| phone_number    |            |                           |
| user_role       |            |                           |
| login_id (UQ)   |            |                           |
| password_hash   |            |                           |
| is_active       |            |                           |
| failed_login_cnt|            |                           |
| locked_until    |            |                           |
+-----------------+            |                           |
        |                      |                           |
        v                      |                           |
tb_otp_session (OTP)           |                           |
+-----------------+            |                           |
| otp_id (PK)     |            |                           |
| user_id (FK)    |            |                           |
| otp_code        |            |                           |
| vehicle_id (FK) |------------+                           |
| phone_number    |                                        |
| expires_at      |                                        |
| is_verified     |                                        |
+-----------------+                                        |
                                                           |
tb_dispatch (배차)                                          |
+-------------------+                                      |
| dispatch_id (PK)  |                                      |
| vehicle_id (FK)   |--------------------------------------+
| company_id (FK)   |---+
| item_type         |   |
| item_name         |   |
| dispatch_date     |   |
| dispatch_status   |   |
| created_by (FK)   |   |
+-------------------+   |
        |                |
        | 1:N            |
        v                |
tb_weighing (계량실적)    |
+-------------------+    |
| weighing_id (PK)  |    |
| dispatch_id (FK)  |    |
| vehicle_id (FK)   |    |
| scale_id (FK)     |--->| tb_scale (계량대)
| weighing_type     |    | +------------------+
| weighing_step     |    | | scale_id (PK)    |
| gross_weight      |    | | scale_name       |
| tare_weight       |    | | location         |
| net_weight        |    | | scale_type       |
| weighing_mode     |    | | max_capacity     |
| lpr_plate_number  |    | | is_active        |
| ai_confidence     |    | +------------------+
| status            |    |
| weighed_at        |    |
+-------------------+    |
    |           |        |
    |           v        |
    |   tb_weighing_slip |
    |   (전자 계량표)     |
    |   +--------------+ |
    |   | slip_id (PK) | |
    |   | weighing_id  | |
    |   | slip_number  | |
    |   | slip_data    | |
    |   | shared_via   | |
    |   +--------------+ |
    |                    |
    v                    |
tb_gate_pass (출문)      |
+-----------------+      |
| gate_pass_id(PK)|      |
| weighing_id(FK) |      |
| dispatch_id(FK) |------+
| pass_status     |
| passed_at       |
+-----------------+

tb_master_code (공통코드)     tb_audit_log (감사로그)
+------------------+         +------------------+
| code_id (PK)     |         | audit_id (PK)    |
| code_group       |         | event_type       |
| code_value       |         | user_id          |
| code_name        |         | ip_address       |
| sort_order       |         | detail           |
| is_active        |         | created_at       |
| parent_code_id   |         +------------------+
+------------------+

tb_notification (알림)        tb_inquiry_call (문의)
+------------------+         +------------------+
| noti_id (PK)     |         | call_id (PK)     |
| user_id (FK)     |         | user_id (FK)     |
| noti_type        |         | inquiry_type     |
| title            |         | target_dept      |
| message          |         | call_status      |
| is_read          |         | created_at       |
| sent_at          |         +------------------+
+------------------+
```

### 13.4 용어집

| 용어 | 영문 | 설명 |
|------|------|------|
| LPR | License Plate Recognition | 차량번호판 자동인식 장치 |
| LiDAR | Light Detection and Ranging | 레이저 기반 거리 측정 센서 (차량 감지용) |
| OTP | One-Time Password | 일회용 보안 비밀번호 (6자리 숫자) |
| 인디게이터 | Indicator | 계량대에서 중량값을 표시/전송하는 장치 |
| 전자 계량표 | Electronic Weighing Slip | 종이 계량표를 대체하는 디지털 계량 증빙 |
| 배차 | Dispatch | 차량 운송 스케줄 배정 |
| 계량대 | Scale / Weighbridge | 차량 중량을 측정하는 시설 |
| 총중량 | Gross Weight | 차량 + 적재물 합산 중량 |
| 공차 중량 | Tare Weight | 적재물 없는 차량 자체 중량 |
| 순중량 | Net Weight | 총중량 - 공차 중량 = 적재물 순수 중량 |
| RS-232C | - | 직렬 통신 표준 (인디게이터 통신용) |
| JWT | JSON Web Token | 인증 토큰 표준 (Stateless 인증) |
| RBAC | Role-Based Access Control | 역할 기반 접근 제어 |
| bcrypt | - | 비밀번호 해싱 알고리즘 (단방향) |
| AES-256 | Advanced Encryption Standard | 대칭키 암호화 알고리즘 (256bit) |
| TLS | Transport Layer Security | 통신 암호화 프로토콜 |
| WAL | Write-Ahead Logging | PostgreSQL 트랜잭션 로그 (PITR 복구용) |
| PITR | Point-in-Time Recovery | 특정 시점 복구 |
| RPO | Recovery Point Objective | 데이터 손실 허용 시점 (복구 시점 목표) |
| RTO | Recovery Time Objective | 서비스 복구 소요 시간 목표 |
| HikariCP | - | JDBC 커넥션 풀 라이브러리 |
| ELK Stack | Elasticsearch + Logstash + Kibana | 중앙 집중 로그 관리 시스템 |
| Prometheus | - | 시계열 메트릭 수집/저장 시스템 |
| Grafana | - | 메트릭 시각화 대시보드 도구 |
| Active-Active | - | 두 서버가 동시에 트래픽을 처리하는 이중화 구성 |
| Rolling Update | - | 서버를 순차적으로 업데이트하는 무중단 배포 방식 |
| Failover | - | 장애 발생 시 대체 시스템으로 자동 전환 |
| CSP | Content Security Policy | 웹 보안 헤더 (XSS 방어) |
| OWASP | Open Web Application Security Project | 웹 애플리케이션 보안 프로젝트 |

---

**문서 이력**

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|----------|
| 1.0 | 2026-01-29 | 시스템관리팀 | 초판 작성 |
| 1.1 | 2026-01-29 | 시스템관리팀 | 사용자관리 API 보완(역할변경, 비밀번호초기화, 삭제), 시스템 설정 관리 추가, 공지사항 ADMIN 관리(등록/수정/삭제/게시/고정) 추가, FAQ ADMIN 관리 추가, 장비 모니터링 API 보강(요약/헬스체크), 마이페이지/즐겨찾기/공지사항/통계/대시보드/출문/LPR API 추가, 역할별 접근 권한 매트릭스 갱신 |
| 1.2 | 2026-01-29 | 시스템관리팀 | 웹 프론트엔드 신규 기능(온보딩 가이드, 키보드 단축키, 빈 상태 UI, 숫자 애니메이션, 탭 활성화 감지) 반영, 모바일 오프라인 캐시 반영, 데스크톱 스플래시 폼/하드웨어 인터페이스 추상화/xUnit 테스트 반영, 페이지 레지스트리 기반 중앙 라우팅 관리 반영, 모듈별 상세 설계 문서 참조 추가 |
| 1.3 | 2026-01-30 | 시스템관리팀 | 관리자 기능 확장: 공지사항 관리(카테고리/발행토글/고정토글/관리자전용목록) 상세화, FAQ 관리(카테고리/정렬순서/공개여부/조회수/관리자전용목록) 상세화, 시스템 설정 관리(카테고리별 조회/설정 유형/개별수정/일괄수정/편집가능여부) 상세화, 장비 모니터링 관리(유형별/상태별 필터/수동상태변경/헬스체크/요약대시보드/WebSocket알림) 신규 추가, 문의/민원 관리(문의유형/관련정보확인/처리자메모) 신규 추가, 통계/보고서 관리(일별/월별통계/필터조건/요약통계/엑셀내보내기) 신규 추가, 즐겨찾기 관리(유형/제한/순서변경) 신규 추가, 문의/민원 관리 API 추가 |

---

## 부록 C: 운영 참고 - 신규 아키텍처 요소 (v1.2)

### C.1 페이지 레지스트리 기반 라우팅

웹 프론트엔드의 모든 페이지는 `frontend/src/config/pageRegistry.ts`에서 중앙 관리된다. 새 메뉴 추가나 권한 변경 시 이 파일을 수정한다.

```
주요 설정 항목:
- component: React.lazy 기반 코드 분할 컴포넌트
- title: 메뉴/탭 표시명
- icon: Ant Design 아이콘
- closable: 탭 닫기 가능 여부 (계량소 관제는 false)
- roles: 접근 가능 역할 배열 (미지정 시 전체 접근)
```

### C.2 웹 프론트엔드 신규 기능 목록

| 기능 | 파일 | 운영 영향 |
|------|------|----------|
| 온보딩 가이드 | `OnboardingTour.tsx` | 신규 사용자 교육 부담 감소 |
| 키보드 단축키 | `useKeyboardShortcuts.ts` | 담당자 업무 효율성 향상 |
| 빈 상태 UI | `EmptyState.tsx` | 데이터 없음 상태 안내 개선 |
| 숫자 애니메이션 | `AnimatedNumber.tsx` | 대시보드 KPI 시각적 효과 |
| 탭 활성화 감지 | `useTabVisible.ts` | 탭 전환 시 데이터 자동 갱신 |
| 드래그 정렬 | `SortableTable.tsx` | 테이블 행 순서 변경 UX 개선 |

### C.3 모바일 오프라인 캐시 운영

모바일 앱에 `OfflineCacheService`가 추가되어 네트워크 불안정 환경에서도 기본 데이터 조회가 가능하다.

| 항목 | 설정 |
|------|------|
| **저장소** | SharedPreferences (기기 내부 저장소) |
| **캐시 대상** | 배차 목록, 계량 이력 |
| **유효기간** | 1시간 (자동 갱신) |
| **용량 제한** | 기기 저장소에 의존 (경량 데이터만 캐시) |
| **보안** | 민감 데이터(토큰 등)는 flutter_secure_storage에 별도 저장 |

### C.4 데스크톱 아키텍처 개선

WeighingCS 프로그램에 다음 개선이 적용되었다:

| 개선 항목 | 설명 |
|-----------|------|
| **SplashForm** | 앱 시작 시 초기화 상태 표시 (설정 로드, 장비 연결 확인) |
| **인터페이스 추상화** | `ILprCamera`, `IVehicleDetector`, `IVehicleSensor` 인터페이스로 하드웨어 분리 |
| **시뮬레이터** | `Simulators/` 디렉토리에 각 장비의 시뮬레이터 구현 (개발/테스트용) |
| **xUnit 테스트** | `ApiServiceTests`, `IndicatorServiceTests`, `LocalCacheServiceTests` 단위 테스트 |

### C.5 상세 설계 문서 참조

각 모듈의 상세 설계 문서가 `docs/design/` 디렉토리에 추가되었다:

| 문서 | 대상 모듈 |
|------|----------|
| `auth-basic-design.md` | 인증 기본 설계 |
| `auth-detail-design.md` | 인증 상세 설계 |
| `dispatch-detail-design.md` | 배차 모듈 상세 설계 |
| `weighing-detail-design.md` | 계량 모듈 상세 설계 |
| `gatepass-slip-detail-design.md` | 출문/전표 모듈 상세 설계 |
| `lpr-otp-notification-detail-design.md` | LPR/OTP/알림 모듈 상세 설계 |
| `ui_ux_recommendation.md` | UI/UX 설계 가이드 |

---

*본 문서는 부산 스마트 계량 시스템의 운영 및 관리를 위한 공식 매뉴얼이다. 시스템 변경 시 반드시 본 문서를 갱신해야 한다.*
